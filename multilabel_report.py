# -*- coding: utf-8 -*-
"""Multilabel Report.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1y8C8yFfLOHLuA-al00I0TrdgXFiNdg9b

## **Task 2 Contract Clasification:** Classify each contract into the corresponding classes

Class: CS987

Group: AE

Andrea Oteo: 202059017, Ane Etxeandia Erauskin: 202077594, Crawford Middleton: 202082754, Daragh McCarthy: 202075755, Elijah Reid: 202093659

# Please Read Before Running Notebook:
**Three Layer Neural Network** uses Tensorflow version 1.x

**LSTM & GRU** use Tensorflow version 2.4.1

Choose which cell to run below. Notebook will require restart when switching in between.
"""

# For 3 Layer NN, Run...
#########################
"""
!pip install tensorflow==2.4.1
import tensorflow
print(tensorflow.__version__)
from tensorflow import keras
from tensorflow import initializers
import pandas as pd
import numpy as np
import re
from sklearn.model_selection import train_test_split
from keras.preprocessing.text import Tokenizer
from keras.preprocessing.sequence import pad_sequences

# Commented out IPython magic to ensure Python compatibility.
# For LSTM and GRU, Uncomment and Run...
#########################

# %tensorflow_version 1.x
import tensorflow
print(tensorflow.__version__)
from tensorflow import keras
from tensorflow import initializers
import pandas as pd
import numpy as np
import re
from sklearn.model_selection import train_test_split
from keras.preprocessing.text import Tokenizer
from keras.preprocessing.sequence import pad_sequences

"""# Overview and Abstract

This notebook tackles the contract classification multi labelling task using five models: Logistic Regression (Basic Machine Learning Model), 3 Layer Dense Network, LSTM, GRU and BERT. The report will outline the methods used, results and future recommendations. Following the references, the code for all models is included, starting with functions, data reading and preprocessing. Finally, the code is broken down by model.

The Logistic Regression was used as it was understandable, explainable and simple to model to implement, providing a valuable benchmark for more complex neural networks to be compared against with an Mean-F1 score of 0.64. The best Deep Dense surprisingly had surprisingly few layers with only 3 resulting in a Mean-F1 of 0.56, lower than the Base ML. The LSTM and GRU models had a similar architecture with Mean-F1 scores of 0.48 and 0.51 respectively. Finally, the BERT model had the best Mean-F1 score of 0.75, but it failed to achieve the target Mean-F1 score of 0.90+.

# Methods

###  Describe the data processing, feature extraction performed and reasoning.

**Base ML Model- Logistic Regression**

The description feature was cleaned used the clean function outlined in the functions section in order to make it improve readibility for the logistic regression model. This step was common across all models in this report. Next, the tfidvectorizer was instantiated on used on the text data in order learn the vocabulary in the training data which was then used it to create a document-term matrix. The vectorizer will tokenize the documents, learn the vocabulary and inverse document frequency weightings, and enabling the model to encode new documents.


**Dense Deep Network (3 layer)**: The data cleaning for this model starts deleting the columns that were not considered to provide useful information to the model. 
Those columns are: publication_date, country_code, country_name, sector, value, description and awarding_authority. The country_code, country_name and sector were removed because all instances had the same value in that column. The others have been deleted due to the difficulty of transforming them into dummie variables because of their many different values.
The “title” column contains two pieces of information: the city and the title. For this reason, it has been separated in order to create an additional feature with the name of the city. In the column "nature of contract" there is just one instance with the "Combined" value in the test dataset. There are no instances containing this value in the training set. Therefore, and as it is not possible to delete rows from the test dataset, this instance has been treated as if it had the most common value in this column: work.
In the "title" and "city" columns there are a lot of different values. In order not to make a huge dataset when creating the dummie variables, it has been decided to create dummies for only the most important ones, and to assign the other ones the value 'other'.
In the "category" column each instance can have more than one category, so the MultiLabelBinarizer was used to create the dummy variables. 

  **LSTM, GRU and BERT**: the models are able to read natural language so categorical variables have been used to train the model. For this purpose, all the variables that can provide useful information have been joined in a single column called "features". Afterwards, the model has been processed by removing capital letters, punctuation marks and any other symbol that does not provide information. Stopwords have also been deleted and lemmatisation has been applied to the dataset. A Tokenizer instance is fitted "fit_on_texts" to the corpus creating a vocabulary index based on word frequency. Every word is mapped to an index, so every word gets a unique integer value, lower integer means more frequent words. The size of words to keep is defined by the num_words parameter, in this case, "vocabulary_size". Only the most common words will be kept. The sentences from the input are then mapped to integers using the "tokenizer.texts_to_sequences" method. For the "categories" column, which contains the different classes, a method called MultiLabelBinarizer has been applied that allows you to encode multiple labels per instance. To translate the resulting array, a DataFrame is built with this array and the encoded classes and it is added to the one we had. 
Finally, in order to create embeddings, all of the sentences need to be of same length. Therefore, the "pad_sequences" is used to pad each sentence with zero. At the end, the dataset is split in trining and test set.

### Describe the baseline model to be used (and why it was selected)

The standard machine learning baseline model that we have selected was logistic regression. The algorithm estimates the probability of each document belonging to the 9 different categories.  If the estimated probability for a category is above 0.5 the algortihm will predict the document belongs to that category by labelling 1. In contrast, if the estimated probability is below 0.5 then the algorithm will predict the document doesn't belong to the category by labelling it 0. The algorithm is appropriate for the dataset as it is a binary classification, which is predicting a yes/no outcome. The logistic regression is a good baseline model as it is easy to implement with a fast learning rate.

### Describe each neural model configuration / setup that will be used.

**Dense Deep Network:** A neural network of three dense layers, each with 50 neurons, has been constructed. The SELU function has been chosen as the activation function, which solves the vanishing gradient problem, since the output of each layer will tend to preserve a mean
of 0 and standard deviation of 1 during training. As kernel initializer, the lecun_normal has been chosen as the use of the SELU activation function requires it. Dropouts with a rate of 0.5 have been used as a regularisation technique in order to improve the score. Finally, the output layer has 9 neurons, one for each class, and the sigmoid activation function has been used, giving as output a number between 0 and 1 that represents the probability that the instance belongs to each class. Adam with a learning rate of 0.001 has been used as an optimiser as it is one of the preferred optimisation algorithms in existence. 

   **LSTM/GRU:** In this case the input sequences are words and we have approximately 6000 words per instance. However, a reasonable limit of 250-500 max sequence length is often used in practice with large LSTM models. For building this model we'll use the Keras functional API and not the common used Sequential() model. This is because with this API it's possible to build more complex models, such as multi-output and multi-inputs problems.
We will be training our own embeddings using Keras Embedding Layer. A Convolutional layer was added before the LSTM in order to speed-up the training time. A Dense layer is created for each of ouput. The corresponding metrics and losses for each output will also be stored into dictionaries. For each output we define the weight in a dictionary format (class 5 is different from the rest) and these values are obtained through calculations. Early stopping is implemented to help limit overfitting. Finally, a Model class is instantiated and the model is trained. 

   **BERT**: The same data cleaning was applied to BERT and the max sequence length was set at 250. The model used the huggingface PyTorch library. Beforehand, the text data was split into tokens and mapped to their index in the tokenizer library. The final model used "multilingual-base-cased" as the text was german. The text was procesed for bert by truncating the sentence length to a maximum of 250 as the majority of text data was shorter than this limit. The final model was trained over three epochs in order to avoid overfitting, with batch size of 16 and a learning rate of 2e-5. The AdamW optimizer was used as it is a class from the hugginface library. A weight decay of 0.1 was used.

### Model Functions and Classes

Standard Machine Learning Model

https://colab.research.google.com/drive/1y8C8yFfLOHLuA-al00I0TrdgXFiNdg9b#scrollTo=4h2z_HpkyOfR&line=1&uniqifier=1

Dense Deep Network

https://colab.research.google.com/drive/1y8C8yFfLOHLuA-al00I0TrdgXFiNdg9b#scrollTo=hHVTQ5Evygr5

LSTM Network

https://colab.research.google.com/drive/1y8C8yFfLOHLuA-al00I0TrdgXFiNdg9b#scrollTo=HV6WHtytyhF_

GRU Network

https://colab.research.google.com/drive/1y8C8yFfLOHLuA-al00I0TrdgXFiNdg9b#scrollTo=ChBpYjMtyoZ9&line=1&uniqifier=1

BERT Network

https://colab.research.google.com/drive/1y8C8yFfLOHLuA-al00I0TrdgXFiNdg9b#scrollTo=uqhixX7lyrdP&line=1&uniqifier=1

### Describe the training schedule and approach that you undertook.

**LSTM and GRU:** Both networks used to the Adadelta optimizer whichis an extension of Adagrad that seeks to reduce its aggressive, monotonically decreasing learning rate. 

**BERT**: The BERT model used the Pytorch Linear learning rate schedule in order to find the optimal learning rate while using the adaptive AdamW optimizer. The final model used a learning rate of 2e-5 with a weight decay of 0.1. The weight_decay parameter adds a L2 penalty to the cost can lead to smaller model weights. The Learning Schedule did not improve the highest kaggle score above 75%. It would appear that the learning schedule has not been optimally integrated into the neural network.

### Describe any other things that you did or tried in order to improve performance

**Baseline Model:** We noticed there was an imbalance within the dataset due to a higher percentage of Infrastructure & Construction instances within the labels. We balanced the data by using the smote technique, which saw no improvement on the kaggle score. 

**Dense Neural Network:** RandomizedSearchCV has been used to search for the most suitable hyperparameters for the dense neural network model. Different numbers of layers, numbers of neurons and learning rates have been tested. The execution time was very long, and before it finished running it was interrupted with the following error: "Cannot clone object <tensorflow.python.keras.wrappers.scikit_learn.KerasRegressor object at 0x7fe0a87b3450>, as the constructor either does not set or modifies parameter n_neurons". The best parameters so far have been extracted and the model has been retrained with them. The results have been worse than the ones we had before, we think it could have been due to overfitting. For this reason, other combinations have been randomly tested and finally we have left the one that gave the best results. 

**Bert:** XLNet model was also constructed from the hugginface library with 'english-base-cased' which led to 5% lower mean-f1 on kaggle. The final Bert model was  run without the same text cleaning as used in LSTM and GRU. This was done to investigate the influence of this technique on performance. It consequently led to a 5% reduction in performance. A final comparison was constructed by using only the description instead of the features, and it again underperformed by approximately 5%. The model was run with one, two and three epochs. There was no clear difference in performance betweent the three levels.

# Results and Discussion

**Scores from Kaggle Leaderboard**
 - The Basic model: 0.64 Mean-F1 score on kaggle leaderboard

 - The Dense Deep Model: 0.55 Mean-F1 score on kaggle leaderboard

 - The LSTM Network: 0.50 Mean-F1 on Kaggle leaderboard.

 - The GRU Network: 0.48 Mean-F1 on Kaggle leaderboard. It performs a little bit worst than LSTM. In addition, being a simpler model with which the execution time should be reduced with respect to LSTM, this has not been the case. The execution time was very similar. 

 - The BERT Network: 0.75 Mean-F1 on Kaggle leaderboard using the multingual-based-cased hugginface library with Pytorch. This model fared better than XLNet (5% improvement).

**Table of Approaches with parameter settings and performances**

![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALMAAABPCAIAAAAvJmPGAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAs6ADAAQAAAABAAAATwAAAABJo4t+AAARhUlEQVR4Ae3ddZAkt84A8HdhZuZ8YWZOhenCqaTCXGGoYIWZmZmZmZmZmZmZmd77XfTF8fb0zM3C3e3sdv8x47ZlWZZlWXZbdp8XXnjhP9VTcaCGA0OImW666Wriq4h/OfDiiy/2Nhap8mD/MqAKVRzIOFBJRsaMKphxoJKMjBlVMONAJRkZM6pgxoFKMjJmVMGMA/3mJtXTHThw//33P/jgg3PMMceiiy7aHegp6oxjjjlmsskm+7+/n8knn3yuuebadtttX3vtte5Aazeh4cADDwz++MWiWWeddeONN37mmWc6Q95vv/3Wt2/fXXfddb311msXnjPOOGOKKaZAyTTTTHPssccW8n7//ffLLbdcNOicc8759ddfA9hkk03GHHNMlP/4448F+DavVrr+mz2LLLJIm+S/X4Ybbrg77rgjg+q+wTPPPHPEEUccbbTRXnrppa6ishkWDTHEEHfeeWeHS/zjjz/QjNlasV1IcgUz+OCDf/DBB3n2I444Im/NRx55RGpq4i+//DIHzsOqXNQZCdHpp59+6qmnzjvvvGJ++umnLbbYIiV158Dnn3+uo3z11VfffffdgKbz+uuvv+yyy1ZaaSUFadrDDz+8wyVqVEPJTTfd9PDDD7cLieZM8H/++eeFF16YXgXOPvvs/DUHzuPLw/U6xDfffAMRhTPCCCNEzhAxrD/ssMOWXnrpmWeeebbZZlt77bUfe+yxJG704WqrrXb33Xfvu+++ANZaay1JzWS577778GXVVVedZZZZ4Hz99dd/+eUXettwtuCCC+63336///57KuXTTz/daaedFltsMRpy/fXXT/rsgAMOQFJQu+yyy2600Ub33ntv5KqXRWopzaksgXosIg1SDQSDDdavg0066aSRq3F9qfS9995bX59xxhmx8bzzzotce+21F9YRr3j1SwFst912uvjss89uwCrVgqEARh111AkmmAAN008/fcquXYIVWBoBYie1SZ3xn3rVDsmAyIAUeL/44guvU001VbymX3x59NFH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)

![Screenshot 2021-04-11 at 15.43.05.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABGgAAACNCAYAAADrTEwSAAABQ2lDQ1BJQ0MgUHJvZmlsZQAAKJFjYGASSSwoyGFhYGDIzSspCnJ3UoiIjFJgf8rAwsDNwMMgxmCUmFxc4BgQ4ANUwgCjUcG3awyMIPqyLsisuaecldmnT33yZVb3z76devcw1aMArpTU4mQg/QeIU5MLikoYGBhTgGzl8pICELsDyBYpAjoKyJ4DYqdD2BtA7CQI+whYTUiQM5B9A8gWSM5IBJrB+ALI1klCEk9HYkPtBQFuH3cFt1AfHwUPFwKuJQOUpFaUgGjn/ILKosz0jBIFR2AopSp45iXr6SgYGRgZMjCAwhyi+vMNcFgyinEgxAqBfrTyZGBgykWIJQQwMOz4APIqQkxVh4GB5zgDw4HYgsSiRLgDGL+xFKcZG0HY3NsZGFin/f//OZyBgV2TgeHv9f//f2/////vMgYG5ltAvd8ARwdgit0rBsgAAABWZVhJZk1NACoAAAAIAAGHaQAEAAAAAQAAABoAAAAAAAOShgAHAAAAEgAAAESgAgAEAAAAAQAABGigAwAEAAAAAQAAAI0AAAAAQVNDSUkAAABTY3JlZW5zaG90YPrOjgAAAddpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDYuMC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+MTQxPC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjExMjg8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpVc2VyQ29tbWVudD5TY3JlZW5zaG90PC9leGlmOlVzZXJDb21tZW50PgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KyV2YyAAAQABJREFUeAHsnQO4ZMfTxnvjjW1sbGPjbGzbtu1kY9ve2LZt27adjec7v8pX8z9zdg5m7ty9g7eeZ3Tcb3dXVb9V3dOrFEmQCAEhIASEgBAQAkJACAgBISAEhIAQEAJCQAj0GAJD9NiddWMhIASEgBAQAkJACAgBISAEhIAQEAJCQAgIAUNABI0aghAQAkJACAgBISAEhIAQEAJCQAgIASEgBHoYARE0PVwBur0QEAJCQAgIASEgBISAEBACQkAICAEhIARE0KgNCAEhIASEgBAQAkJACAgBISAEhIAQEAJCoIcREEHTwxWg2wsBISAEhIAQEAJCQAgIASEgBISAEBACQkAEjdqAEBACQkAICAEhIASEgBAQAkJACAgBISAEehgBETQ9XAG6vRAQAkJACAgBISAEhIAQEAJCQAgIASEgBETQqA0IASEgBISAEBACQkAICAEhIASEgBAQAkKghxEQQdPDFaDbCwEhIASEgBAQAkJACAgBISAEhIAQEAJCQASN2oAQEAJCQAgIASEgBISAEBACQkAICAEhIAR6GAERND1cAbq9EBACQkAICAEhIASEgBAQAkJACAgBISAERNCoDQgBISAEhIAQEAJCQAgIASEgBISAEBACQqCHERBB08MVoNsLASEgBISAEBACQkAICAEhIASEgBAQAkJABI3agBAQAkJACAiBBiPw7bffhu+++67mq/7555/hww8/rPm8vBPqfZ686zb7/u7CM6vcnYp1HBNhEEej6997As+PPvoo/PPPP11/+Ca8Qr1l6wl90oTw1fRIPdF2a3pAHdwlBOrtS126aQecLIKmhyoZo4fS+vvvv8tP8Mcff9i2ogbx888/D6usskpYZpllwo477li+TtaXa665xo7nnPvvvz/r0Nx933//ffj555/tOMpBeXhJuobAr7/+WsZy4MCBXbtYD5zdHe3itNNOs3Z75pln9kCJ0m/577//hsMOOyysvPLKYaWVVgq33npr+sH/v6fV6zergL///ru13V9++cUOg6BAJ4BTTwm6EX233HLLBXRsUcERpy3767fffit6qh231lprhUMOOWSQcz777LPw/PPPD7LdN5x++ulhiSWWCKVSyTflfuIg0QYp58EHH1z1+LTnqXrwYN6InnP7UWtbefbZZwO2ME3qwTPtWr49756DE2tssGPnn26X/Xkb/Uk/euihhyr8l+Q9BicGyXvTdx0LPov6VMnr1Pq7Xl1T5D6NxjNPD73zzjthgQUW6LKfWKRsacegA99///1Af3ObknZsfHte++xK2bpDn8SfvSvf3d7S5mvVo125b965jW67afejvXSl3+fp9bT71rLdfSR/zlrqKa9dpz3HdtttZ75BvWM+9OlTTz0VPvjgA/Nd4uPWrvSltOetZXsST8e1lmvUciz6CF8LfxJculNE0HQnuhnX3nXXXcNss80WVlhhBTsKB3Xeeee1bQxGi8gII4wQppxySovSvvbaa0VOCeONN14YZ5xxwquvvhq++uqrQudUO+imm24Ks8wyS5h55pnDSy+9FDbYYAN7dspUZJBa7ZraFsKPP/4YZpxxxjKWyy67bEvB0l3tYqKJJgq08ffee6+p8LjnnnvC2WefbX2K/kufzJJWr9+ssrFvnnnmsbaLXsCRnXXWWe33ueeem3dqt+1HR2JIX3755fDXX38Vvs9iiy1mOg49x2uGGWYIP/zwQ+Hz0YWUPynHHXdc2HzzzZOby7/79OkTFl544dCrV6/ytrwvbgtwoHCYqkna81Q7dnBuY/A8xxxzlHUezmQtss4664Qs4rYePPPun3fPwYX166+/bu2S+yVfeWXoyv5HH300rL/++uG5555LvczgwqDaA0BUJvE4/PDDqx3a0G316poiD9FoPPP0EDploYUWChNMMEGRx2v4MQy01l577dCvXz8LRM4+++zhqquuKnSfvPbZlbJ1hz4pVKicgy677LKyvaWtnHjiiTlnDL7djW67aU9+0kknVfT7mWaaKWy22Wbhyy+/TDulYnueXq84uM4f8803X8UzzjXXXOHUU08tdLW8dp12kbHGGsvGfEVx8OtAeBHwwY8Bx0UXXdQCkYwfXbrSl/waXflM4ul6/8knn+zKZVPPHWmkkSzQhz/Z3QQNUTpJDyAQMZCliSee2F5RNLV044032vf555+/FDGqpajiS0cffXQpimCUIiVTWm211UpPP/20PWk0yChFxrW09NJLl9Zcc83SggsuWIoGE+VSPP7446Uos6YUDfRLkYEtnXfeeeV9fHnxxRftXldccUXF9lp/rLvuunadVVddtcQzLb/88qWIqLHLfP3116UomlSac845S5FhLe2yyy6lKBJtZePZok5l5bngggtKlHm//faz82655RYrc+Rgle67777S4osvXooGR6WI9LH9d955ZykiLUrRYKkUDWJK55xzjl0zGriXIuVhr0033dTO2X333e25OJEy82zTTz+9PQ+YRh3Yrpn2Rh2tuOKK9jzbbLNN+Z48o0sW1tyfch511FGlI444wrCInI1S5Hj46VU/I7LO6o7n5Rni8s0331g5ooFwKXIGSxGLW6LsCO0FLLlHpMgNJ+6/xRZb2P60OmFnvc9qF068pbUL2nVa3VMu2nCUhVLq27dvaZFFFrH2HZEepYgEsTtMPvnkpSizwI6JiM3SgAEDynfurrKltTduTB+k79GPqau99tqr/DxZX7qrfutti1EEohQRxqW55567NN1005VoW/37988qQuq+KEJjeFx++eWlyEEsTTrppKWItLPjqf9oIG3tk/5LW4gGeLYvivxZ3dJ+b7vtttKGG25ofYB2mde3s+reHzQanNlzRZkFvin3k7738MMP23kRCVeKold2Tt7zoOdop/S9yKmpuM+VV15p7Zy+e8wxx9jL+y8H7rnnnnYeOHz66acV55511lnWL6gj+gk2Iyn0l2jgXLE563ki0tPqg2f11wknnGDn11tfFTcv+IP6p3/T7+lPEdFUPpP6jUibUuR4mS3E3qD3IrKzFDnkdjy2EDxPOeWUUkT4lM9NwzNPV6ZhnXfPLKyzbPoll1xiuhvbhV2j/mkrReSggw4yDOjH6KsLL7ywNNlkk+Xa2k022cTq3LHFl6A9uKBPsH+0N9oGbToaSJgt3WqrreyeO+ywg+HuOppz68Ug73n8uYp8RkEje76LLrqohG1Zcskl7fcnn3xip2fpSnQS9oVy09bwK7Cpd911l33S1hB0FLjce++99tvfqumaLLudpfu4ZhaeWX5N1j3z9NAdd9xhto3yXXrppV40+4yy9UoRwWz9MRpcmm/HvfL0YsVFCvxAj6ELwD3KnilFg+fSJJNMYr5Nll8GJlntM61s+Kj421wb33m99dYzfRNlQZafNk2fZOlRTk5rb3l1X75xwS/0QzCLyJpBzsiyk1ltJcsnz9NbaW03r61EgZDS9ttvb348/gi6CZ2YN2bBZnEcbYU2g98NHuhzhDEF45QogFSaZpppSjvvvLNtz9PrWbbQLlDD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rC4rBISAEBACQkAICAEhIASEgBAQAkJACAiBogiIoCmKlI4TAkJACAgBISAEhIAQEAJCQAgIASEgBIRANyEggqabgNVlhYAQEAJCQAgIASEgBISAEBACQkAICAEhUBSBoeIHvvbaa/Gf+i4EhIAQEAJCQAgIASEgBISAEBACQkAICAEh0EAEpptuuqpXq/ib7YEDB1Y9SBuFgBAQAkJACAgBISAEhIAQEAJCQAgIASEgBLqOQO/evateRFOcqsKijUJACAgBISAEhIAQEAJCQAgIASEgBISAEBh8CIigGXxY605CQAgIASEgBISAEBACQkAICAEhIASEgBCoioAImqqwaKMQEAJCQAgIASEgBISAEBACQkAICAEhIAQGHwIiaAYf1rqTEBACQkAICAEhIASEgBAQAkJACAgBISAEqiIggqYqLNooBISAEBACQkAICAEhIASEgBAQAkJACAiBwYeACJrBh7XuJASEgBAQAkJACAgBISAEhIAQEAJCQAgIgaoIiKCpCkt7bPz7779DqVRqj8KoFEJACAiBFkPg33//De+//3746KOPwj///NNiT6/HFQK1I/Dtt9+GH374ofYTdYYQaAME8LslQkAICIGuIlCYoLnvvvvCOuusExZbbLGw8847h++++66ue1988cVhmmmmKb/69u0bNt100/D222/Xdb1aT+rp+6c970knnWSYnH/++RWHfPPNN2H66ac33Ct2FPixzDLLhIceeijzyAMPPDD0798/8xjtbB8EHnzwwbD77rtXvH7++WcrIH3w4IMPDptttlk466yzNKBsn2rPLQn6fYcddghbbbVVuOSSS4K3idwT2/wAyBXs1YcfflhTSSHGzz333DD77LOHFVdcMSy55JKhX79+AZwbJWeccYY925133llxyfXXXz+ceeaZFdsGxw/ZksGBcvPe44EHHgjrrbeetfN55503rL766iHZNqs9fTu0m2b1K8H7jz/+CJdeemn47bffqsFfeFtR/+CUU06p8C/QU+0gyy23XJhjjjkMz7TyvPbaa2HOOedM263tPYgAtnyTTTap+wk63Ud68cUXw2677RbwLwYMGBAYm7rcfvvt5j/CDdx///2+ufxJcGrbbbcNN998c3kbfeWII46wOkF/NqvPefnll4ctttgibL/99uGuu+4Kf/31l5UBfYqfBX9x0EEHhU8+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83367BwEaD8MHukjGKm40HdoJ41op/Hr6ntzI4COYl0EnE+tKVK8rvJ0O3YE4gUblrRj3IVoFAMwcO8uwbEiU46MVxyIrgp2DP0BicugBJ3B88dtXlfvofNbEwF8SNoGvkm1DLwiPgjtleABBE+7S7W+icNP9hAL6+I3kpUd9+Wy/L8s7PANIX66IkX9A44jgwad091jha6Up1Hnol8JEDO1Ly6MCfDHfbYB4xbImiRZED9H3wcvAkXHevKRsuuFPsBUap9inX30f3vBnqzeVh1vQC4xFocTSfpwRXUlSKSt9VgTQVME8J46xgka/+eLnnoO3VcICAEhIASEgBAQAkJACNSKgBM0pP1LhIAQEAJCoL0RSCNoCk1xagVoVlhhhUGySVrhufWMQkAICAEhIASEgBAQAkKA9WmY1i8RAkJACAiBzkWgbTJoOrcKVXIhIASEgBAQAkJACAgBISAEhIAQEAJCoFUQSMugKfQvTq1SSD2nEBACQkAICAEhIASEgBAQAkJACAgBISAEWhEBETStWGt6ZiEgBISAEBACQkAICAEhIASEgBAQAkKgrRAQQdNW1anCCAEhIASEgBAQAkJACAgBISAEhIAQEAKtiIAImlasNT2zEBACQkAICAEhIASEgBAQAkJACAgBIdBWCIigaavqVGGEgBAQAkJACAgBISAEhIAQEAJCQAgIgVZEoOJfnFqxAHpmISAEhIAQEAJCQAgIASEgBISAEBACQkAItDoCyqBp9RrU8wsBISAEhIAQEAJCQAgIASEgBISAEBACLY+ACJqWr0IVQAgIASEgBISAEBACQkAICAEhIASEgBBodQRE0LR6Der5hYAQEAJCQAgIASEgBISAEBACQkAICIGWR0AETctXoQogBISAEBACQkAICAEhIASEgBAQAkJACLQ6AiJoWr0G9fxCQAgIASEgBISAEBACQkAICAEhIASEQMsjIIKm5atQBRACQkAICAEhIASEgBAQAkJACAgBISAEWh0BETQ5Nfjtt9+G77//Pueo5tz9999/h1Kp1JwPp6cSAkJACAiBHkfgu+++6/Fn0AMIASEgBNoBAfxuiRAQAkKgqwjURND89NNPYZFFFgnHHHNMV+/bFOcvtdRS4dRTT636LPfee29YffXVQ9++fcNss80WVlhhhXDbbbfZsfPNN1+YZJJJqr6efPLJsPDCC4c+ffqETz75pOLaF110kZ1z5JFHVmznx7HHHmv7zj777Ip9X3/9dZhsssnC/PPPX7G9yA/q6oEHHsg8dJ999gn77rtv5jGdvBOCa8cddwxPP/10BQy33HJL2GqrrcK2224b7rnnnvK+X3/91drU+uuvH/bbb7/w8ccfl/dlfXniiSfCzjvvHFZeeeVAO/njjz8qDv/nn3/C5ptvHm644YaK7Vk/3nvvvbDuuutWHJL1fG+++WbYf//9wwYbbGBl4J6SzkDg7rvvtva88cYbhwEDBgR0vaT5EVhttdXKdgibg21C7/z222+5D499WnLJJcOqq66ae2zaATPPPHN4/PHHTV+ht9AvEiFQCwLt4INccMEF5X6IbzjTTDMFfABsak8LvkQj+mZR/6Bdbcliiy0Wpp9++kF8s3j9vvrqq2GGGWaIb9J3IdDWCJDAwBgp/nrkkUcqynzppZeGU045pWLb888/b+esueaa4ZxzzgmMddtFvvjii8A4f5VVVgnbbLNNeOedd+oqWiGCBuDOOuusAJDvvvtu2wCZll2CkwmokCIvvvhieOihh8Kss84att9+e8umue6668wpxTEdaqihwkEHHVT+zXFcl5cTOl4z/jvtvhx36623+uH2eccddwQGylnnVJxQ4w9/1hpP64jDb7/99rDrrrsaKRKPMkPI7LTTTmG88cYzAg+SxokwBkcXXnhhWHzxxcPvv/9uJF/eoIXOu+mmm4bhhx8+rLfeegGSDocqLieccEK46667wjfffBPfXPX7Dz/8YOfTXmmjcUl7PpTshhtuaA4lSuWmm24ScRcHro2/v/DCC6bvRh111LD88stb+z399NPbuMTtU7R///3XBoIQyPfdd5/pG/TTJptsklvIZ599Nvz444/hzjvvzD027QDujw355ZdfjNzlehIhUAsC7eCDUIZxxx3XAjkE6Q488EAjSVdcccXw6aef1gJHw49tRN8s6h+0qy15+eWXwwcffBD++uuvQPBWIgSEwH8IwAkwziBY468xxhjDdr722mtGzBx22GHh7bffLkP2+eefh7XWWsv8D3gF+hTjj3YQxutbb711eOqpp8JGG21khO5uu+1WV9EKETQYGAaNPW1o6iphHSfReBhc09hGGGGEMNFEE4W99trLnN6BAweGccYZJ4w//vj26tWrVxh99NHLv4cZZhi744wz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IASEgBAQAkJACAgBIdCRCIig6chqV6GFgBAQAkJACAgBISAEhIAQEAJCQAgIgWZCQARNM9WGnkUICAEhIASEgBAQAkJACAgBISAEhIAQ6EgERNB0ZLWr0EJACAgBISAEhIAQEAJCQAgIASEgBIRAMyEggqaZakPPIgSEgBAQAkJACAgBISAEhIAQEAJCQAh0JAJDxUs9cODA+E99FwJCQAgIASEgBISAEBACQkAICAEhIASEgBBoIAK9e/euejVl0FSFRRuFgBAQAkJACAgBISAEhIAQEAJCQAgIASEw+BAQQTP4sNadhIAQEAJCQAgIASEgBISAEBACQkAICAEhUBUBETRVYdFGISAEhIAQEAJCQAgIASEgBISAEBACQkAIDD4ERNAMPqx1JyEgBISAEBACQkAICAEhIASEgBAQAkJACFRFQARNVVi0UQgIASEgBISAEBACQkAICAEhIASEgBAQAoMPARE0gw9r3UkICAEhIASEgBAQAkJACAgBISAEhIAQEAJVERBBUxWW/zb+8MMP4f333w///vtvxlHNu+vvv/8OpVKpeR9QTyYEhIAQEAI9isD333/fo/fXzYWAEBAC7YIAfrdECAgBIdBVBAoTNLfddltYf/31w0orrRTOPPPM8OWXX3b13k17/jvvvBNWX331MPfcc4fll18+zDHHHGGXXXYJv/76qz0zhM20004bpplmmvKrb9++YdNNNw0ffPCBHXPVVVeF+eabb5AyrrrqquHkk08eZPtJJ51k1zr//PMr9n3zzTdh+umnD4sttljF9iI/lllmmfDQQw9lHnrggQeG/v37Zx7TyTshuHbbbbfw7LPPVsBw++23hx122CHsvPPO4f777y/v++2336x/0BYOOuig8Mknn5T3ZX156qmnwp577hnWWmutcOmll4Y//vij4vB//vknbLvttuHmm2+u2J71A3Jxk002qTgk6/nefvvtcPDBB4fNNtssnHXWWYF7SjoDgfvuu8/a81ZbbRUuueSS8PPPP3dGwVu8lOuuu27ZBmGTFl10UdM7AwcOzC3Zp59+GlZYYYWw9tpr5x6bdgB278knnzR9hd5Cv0iEQC0ItIMPcvHFF5f7IX6h+4PY1J4WfIlG9M2i/kG72pLlllvOxgJJ3yxev6+99lqYc84545v0XQi0NQIkMuy+++4Vr8cff7yizFdeeWU444wzKra9+OKLNraCVxgwYEBgrNsuAj9y3HHHmW+10047hXfffbeuohUiaF599VUD8oUXXgjDDTdcgEzYf//967phs5/EwGTDDTcMk0wySXj00UcDZT7vvPPCE088UUFkMHA/+uijw8MPP2yviy66yLJt9t13XysiJE617JW07X7sHXfcUQHR3XffbQNl31+xswE/uG53XbsBj9ejl7jrrrvC3nvvHW655ZYQjzJDyKCQxh13XDPYkDS0AwRSBmeIgdLvv/8e1ltvvdxBC5136623Dr179zaC5oILLgiXXXZZRdlPOeWUcO+994Zvv/22Ynu1Hz/++KOdD7HE4Ckuac+Hkt18880DTtiKK65oZeZYSfsj8NJLLwWMyKijjhqWXnppa79nn312+xe8DUqIPYFgQf8QRFlllVWMMN5yyy1zS/f888+Hn376Kdx00025x6Yd4PaD4MUhhxwS0D0SIVALAt6Gajmn2Y6lDOOMM471wwcffND8BkjSNdZYI3z22Wc9+riN6JtF/YN2tSWMgQi+/vXXX+GBBx7o0frUzYVAMyHw3nvv2ThjxhlnDP4abbTR7BFff/11I2aOOuqoCpLiiy++sHE2/sdqq61mPssWW2zRTMWq+1kIbO+4447hmWeesfEfhO4+++xT1/UKETSwYTiCxx9/fLjiiissOvDII4+Ezz//vK6bNvNJF154YRhmmGHC4YcfHsYYY4ww1FBDhVlnnTUcccQRNoCOP/soo4wSxhprLHtNPfXUAYadqGS9QgQUQxA36Hfeeadl0Pg1MRCHHnpomH/++cMCCywQjjnmmOAplR9++GHYeOONjRwgK+bPP//00ywDZM0117RzaDxFBvrlkzv0yz333GMDmCGHHLICAaJlEC90OiLYCy20UCBjCnLvxhtvDKeeempYZ511bMACKxzPsKm40P//gAAkQ4o6I0MN5rVPnz7lQ+nokERTTTVVeVvWF9hb+mfyubOeDzKqV69egbKRNbbNNtuEG264IRSJxGc9i/Y1PwLod6J+ZE9BzkHSyAlt/nrzJxx++OHNBk066aSWZUcAhYw8CBiE7L+k7n/jjTcsk/O7776z4AvHQfCQwYddITvQ7dAJJ5xgQQqOQfAD0BNxQV8gZN+1UyQsXkZ9L44AA3Wy8U477bSw7LLL2onV2mHyimQYv/nmm+XN/K43+li+yGD6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EAJCQAgIASEgBISAEBACQkAICAEh0FQIiKBpqurQwwgBISAEhIAQEAJCQAgIASEgBISAEBACnYiACJpOrHWVWQgIASEgBISAEBACQkAICAEhIASEgBBoKgRE0DRVdehhhIAQEAJCQAgIASEgBISAEBACQkAICIFOREAETRvX+t9//x1KpVIbl1BFEwJCQAgIASEgBISAEBACjUfg33//Df/880/jL6wrCgEhIAQyEChM0Fx22WVhmWWWCUsttVQ49thjw9dff51x2dbYRTkmmWSS8mvaaacNa621Vvjggw+sANdcc015X/y4Pn36hD/++CPcdNNNFfvZPsccc4T9998//Pnnn+GII46o2B+/BsfExZ/l7LPPjm82nCebbLIw//zzV2wv8mORRRYJDzzwQOah++yzT9h3330zj9HO1kJgjz32CDvuuGPFa6eddjKyDsLuwgsvDOuvv37YdNNNwyOPPFIu3CuvvBIOPvjgsO6664YLLrgg/PTTT+V9+tI+CFx66aXhlFNOqSjQ888/b+1lzTXXDOecc05b6PeKAnbhx1dffRVmmmmmQB9ywWFfaaWVwvLLL18XCX7fffeF2Wef3S9X1yd1iE257bbbKs5fY401wqmnnlqxbXD8kC0ZHCi33z3aod1gL+P+HfoCG/vmm2/2eIXhq1500UXh119/7dKzUBb81g022MD0SxZpgZ+BD/L000936Z7defJbb71ldcZzZgm++Z577pl1SOF92Ndtt922fPx7771nz8A9XO69917b9vHHH/smfXYRgYsvvjhstNFGYcsttwy33357+Ouvv2q+4vHHH1/hUyd9qJov2EEnVPM5v/jii3DkkUeGVVZZJWyzzTbhnXfeaStEGqEDCxE0DOL23nvv8OOPP4ZRRx3VnHsaazvIrLPOGl588cXwwgsvhGuvvTa8++671mgoGwCPMcYYRnJAdPjr/vvvD8MMM4wVf9hhhzUjhCF64oknzIBhDGmQKOLHH3/cXksuuWRYcMEFy7933333qvDdeuutFdvvuOMOY+95lu4Qrttd1+6O59U18xGYYoopwtRTT11+4QTgjCAQgCeffHJYdNFFwyyzzBI23HDD8Omnn4aff/454DwMNdRQYdVVVw2XX355uR/k31FHtAICr732munuww47LLz99tvlR/7888+NmEa/0wZwEGkXkv8QGHvssY24vP766825Y+sZZ5wRwPOEE04IvXr1qhkq+t5pp51W83nxE1xvQ6rGB19EfHtCZEt6AvXWv2c7tBvKMO6445ov+OSTT4YDDzww/Pbbb2HFFVc0+9qTtfTLL7+YX4p+r1e+//57swmQNAyoCE6mBfYYAO+6667hhhtuCN999129t+z286677row4ogjhrvuusvqKu2GjWyfffv2Dc8++2z5Vg8//LB9f+ihh8rb2D/++OOHiSaaqLxNX+pHgLEYPs+UU04ZFlhgAesLyUB4kavjE0844YRh5plnttfkk09e5LSOPibN54Tc3XrrrcNTTz1lxBkk8m677dY2WDVKBxYiaCAeICRwSsmkGWGEEQaJ2rUqsgxIIZ1GG220MN100wUIGwyry5BDDhkmnXTSQV7ulA8xxBABB54XBhqDTCSFQe/II49sihZl27t37zD88MOXf7MvKdNPP314+eWXKww60dEZZ5yxfCjML8af6CvZOocffnhgKhPy/vvvh3XWWSfMN998ZjzJ4nGBQCLiyzl0jG+//dZ36bPNENhiiy2MkYaVhhj87LPPLCuCNnvSSSeFo446ypTi9ttvH4477rgwcODA8Nhjj1nWF0oSB2zllVeuyK5pM4g6sjhkyUBGo+/igm4Ya6yxwoABA6zuiWi/+uqrbRfRiJe51u/oTjJIwQan+sQTT7SoKmQowsCF6Nxss80WyGC58847bTvZaFdccYV9543vHIeuPvPMM207AwBsa79+/exFH2UbwrWolyWWWCIw8EsKziK2heepJh9++GFYe+21A7YFUpbBCEJAYuONNzZ9wHbaABF/sj7nnntu0w+Uc4UVVghzzjmnZc369W+++WbTD9iSrbbaqsJe+TH67EwE3AchGHXIIYeE7bbbLpCZiRTxQZZbbrnw+uuvl8FbdtllK8jk8o4m/IIv6X4gQY6rrrrKAnznnXeePW2yL6f1TQKAZHXstdde5udhiz0TJ8v/S8Nus802s/vTv+vNfGfAgf9AmdCFO+ywgwU0476yVwm6j+xbfOdmFUhsCHfPZL/nnnvKjwrG++23n/nR6O94ZD9NzxfVn/POO28gIIJPhkDM0C7w+3/44QfbBkEzzzzz2He9dR2BBx980OwZhOJ6661nAUjIQwTiER2FjaOfOWGWvCvt/Jtvvgn4zJtssom98Ack2Qik+ZzgTL+C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)

### Explain your findings: What worked, and why?

**Baseline Model:**
  It was clear the best standard machine learning baseline model was the logistic regression as it scored 55% on the kaggle leaderboard. One of the reasons for the logistic regression models outperforming other models could be due to its high bias/low variance algorithm which seemed to work well with the multilabel dataset. 

  **Bert:** 
 The Bert model successfully ran and achieved 75% accuracy on the Kaggle leaderboard. It also served as a benchmark for testing a variety of parameters, and techniques such as data cleaning and imbalancing. The was enabled by following a simple and conventional approach to setting up the data, the necessary bert pre-processing, Bert classes and network design. 

  **Dense Deep Network:** 
The Dense Deep model of three layers succesfully ran and achieved 55% f1 score on the Kaggle leaderboard. In the pre-processing of the data, an augmentation of the data was successfully made by extracting one more feature which has helped to improve the performance of the model

  **LSTM & GRU:**
 Both of the models have successfully run and achieved 50% accuracy on the Kaggle leaderboard. The data cleaning and preprocessing worked for these models as well as for BERT, which is an advantage in terms of saving time and effort. Since the model is a multilabel classification the multilabelbinariser preprocessing method is the one that works for this.

### What didn’t work, and why?

**Bert:** 
 The model was expected to reach 90% plus as it is well-suited to this type of challenge. The large array of parameters available and the complexity in setting up the model architecture warrants revisiting each decision required to set up Bert from start to finish to identify areas of improvement in a systematic way.

  **Dense Deep Network:** 
The model only predicts one of the classes, which happens to be the class that has the most instances in the training data. Techniques like oversampling and assigning different weights to the classes have been tried, but they did not help to solve the problem. A hyperparameter analysis of the model has also been carried out. It was thought that more layers in the model would help to improve performance, but it turned out that the best performance was obtained with three layers. 

  **LSTM & GRU:**
  First of all, we tried to use the methos "one-hot-encoding" in order to set up the classes, but we realised that this method is not adequate for a multilaber problem. We fixed this and the Kaggle score increased considerably. In addition, the fact that the model has a maximum limit of 250-500 max sequence length makes it impossible to enter the 6000 words that have been used as features to train the model. That is why it is possible that if the model could be trained with all the available information, the score would increase.

  **Baseline:**
  Alternative shallow methods were used in our analysis. The second best model was support vector machine, which scored 7% less accuarcy in kaggle than the logistic regression model. The random forest and decision trees algorithms produced the third best Kaggle score with 39%. The smote technique was used to address the imbalance within the dataset, this showed no improvement on the logistic regression model as the kaggle score dropped from 55% to 5%

### Which features were the most important?

**Bert, LSTM & GRU:**
The two options that were used were the feature among all the columns and only using the description. Suprisingly, the description feature on its own led to a lower accuracy score of 70% vs. 75%. This may be attributable to incorrect set up of max sequence length or tokenization. This should be re-examined in future experimentation.

### When does the model fail?

The standard machine learning baseline models which failed were an ensemble learning approach & naive bayes. The models were not supported to a multi-label & multi-output classification. The deep dense model fails when training it with imbalanced data. Other techniques to handle the unbalanced data should be tried to solve the problem and make the model predict more classes. Regarding LSTM and GRU, when the sequence length is higher than 600 the model fails. It could be because it has a maximum limit as mentioned earlier. It also happened that when a lot of epochs are set up, the model stops abruptly. Meanwhile, the report found that one of the main restrictions when using Bert is the memory required to train which creates a time cost when testing a variety of parameters, imbalance techniques and model architectures, etc.

# Summary and Recommendation

The dataset required significant data pre-processing and feature selection in order to handle the text-based data. In the *Code Preprocessing* section, different methods were taken for each model. Furthermore, the complex nature of the neural networks used in terms of parameter choices and choice of libraries means that the models may not be optimially configured for this task. Going forward, each model should be analyed step-by-step to identify problems in model design and parameter selection. 

Overall, the logistic regression had the best success as it's mean-f1 score was only 0.1 behind the highest performing BERT network. Meanwhile, we expected higher results from all of the neural network models. We believe this is attributable to sub-optimal model archicture and parameter selection due to the higher scores on the Kaggle leadership and the layers of complexity associated with these text-based models.

# References

- Aurélien Géron (September 2019) Hands-On Machine Learning with Scikit-Learn, Keras, and TensorFlow, 2nd Edition edn., US: O'Reilly Media, Inc.
- Daniel Da Costa (May 2020) *Text Classifier with Multiple Outputs and Multiple Losses in Keras*, Available at: https://towardsdatascience.com/text-classifier-with-multiple-outputs-and-multiple-losses-in-keras-4b7a527eb858

# Code - Packages
"""

# Include your packages/imports here.

from google.colab import files
from google.colab import drive

import os
import math

import re
from sqlalchemy import create_engine
import nltk
from nltk.corpus import stopwords
from nltk.stem.wordnet import WordNetLemmatizer
from nltk.tokenize import word_tokenize
from sklearn.pipeline import Pipeline, FeatureUnion
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.feature_extraction.text import TfidfTransformer
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.multioutput import MultiOutputClassifier
from sklearn.preprocessing import MultiLabelBinarizer
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, accuracy_score, f1_score
from sklearn.utils.class_weight import compute_class_weight
from sklearn.model_selection import GridSearchCV
from scipy.stats import reciprocal
from sklearn.model_selection import RandomizedSearchCV
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score

from numpy import array
from keras.layers import Conv1D, MaxPooling1D
from keras.callbacks import ModelCheckpoint, EarlyStopping
from keras.preprocessing.text import one_hot
from keras.preprocessing.sequence import pad_sequences
from keras.models import Sequential
from keras.layers.core import Activation, Dropout, Dense
from keras.layers import Flatten, LSTM, GRU
from keras.layers import GlobalMaxPooling1D
from keras.models import Model
from keras.layers.embeddings import Embedding
from keras.preprocessing.text import Tokenizer
from keras.layers import Input
from keras.layers.merge import Concatenate

import tensorflow
print(tensorflow.__version__)
from tensorflow import keras
from tensorflow import initializers
import pandas as pd
import numpy as np
import re
from sklearn.model_selection import train_test_split
from keras.preprocessing.text import Tokenizer
from keras.preprocessing.sequence import pad_sequences

# install earlier version of transformers
!pip install transformers==2.1.1
import torch
from torch.optim.lr_scheduler import LambdaLR
from torch.nn import BCEWithLogitsLoss
from torch.utils.data import TensorDataset, DataLoader, RandomSampler, SequentialSampler
from transformers import AdamW, XLNetTokenizer, XLNetModel, XLNetLMHeadModel, XLNetConfig, BertModel, BertTokenizer
from tqdm import tqdm, trange
from torch.optim.lr_scheduler import LambdaLR

from ast import literal_eval
from sklearn.preprocessing import StandardScaler
import tensorflow as tf
import keras
from keras import backend as K
import math
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix , classification_report, multilabel_confusion_matrix

from sklearn.pipeline import Pipeline
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import StandardScaler
from sklearn.multiclass import OneVsRestClassifier

"""# Code - Functions"""

# Sets up all the metrics that allow for the f1_score to be calculated
METRICS = [
      keras.metrics.TruePositives(name='tp'),
      keras.metrics.FalsePositives(name='fp'),
      keras.metrics.TrueNegatives(name='tn'),
      keras.metrics.FalseNegatives(name='fn'), 
      keras.metrics.BinaryAccuracy(name='accuracy'),
      keras.metrics.Precision(name='precision'),
      keras.metrics.Recall(name='recall'),
      keras.metrics.AUC(name='auc'),
]

def encode_and_bind(original_dataframe, feature_to_encode):
    dummies = pd.get_dummies(original_dataframe[[feature_to_encode]])
    res = pd.concat([original_dataframe, dummies], axis=1)
    return(res)

def clean_text(text):
    text = text.lower()
    text = re.sub(r"what's", "what is ", text)
    text = re.sub(r"\'s", " ", text)
    text = re.sub(r"\'ve", " have ", text)
    text = re.sub(r"can't", "cannot ", text)
    text = re.sub(r"n't", " not ", text)
    text = re.sub(r"i'm", "i am ", text)
    text = re.sub(r"\'re", " are ", text)
    text = re.sub(r"\'d", " would ", text)
    text = re.sub(r"\'ll", " will ", text)
    text = re.sub(r"\'scuse", " excuse ", text)
    text = re.sub('\W', ' ', text)
    text = re.sub('\s+', ' ', text)
    text = text.strip(' ')
    return text

def cleaning(sen):

  clean = re.sub(r"""
               [,.;@#-/\"'():!?!&$]+  # Accept one or more copies of punctuation
               \ *           # plus zero or more copies of a space,
               """,
               " ",          # and replace it with a single space
               sen, flags=re.VERBOSE)
  clean= clean.replace("Germany","")

  clean=re.sub(' +', ' ', clean)

  return (clean)

def clean_text_nn(text):
    text = text.lower()    
    text = text.split()
    stop_words = stopwords.words("german")
    text = [tok for tok in text if tok not in stop_words]
    lemmatizer = WordNetLemmatizer()
    text = [lemmatizer.lemmatize(w) for w in text]
    return ' '.join(text)

# custom function - 3 layer
def Evaluate(model_name):
  test_predictions = model.predict(test_features)
  test_predictions.round(0)

  results = model.evaluate(test_features, test_labels, verbose=0)

  for name, value in zip(model.metrics_names, results):
    print(name, ': ', value)

  return Evaluate

# BERT
def plot_sentence_embeddings_length(text_list, tokenizer):
    tokenized_texts = list(map(lambda t: tokenizer.tokenize(t), text_list))
    tokenized_texts_len = list(map(lambda t: len(t), tokenized_texts))
    fig, ax = plt.subplots(figsize=(8, 5));
    ax.hist(tokenized_texts_len, bins=40);
    ax.set_xlabel("Length of Comment Embeddings");
    ax.set_ylabel("Number of Comments");
    return

# BERT
def tokenize_inputs(text_list, tokenizer, num_embeddings=256):
    """
    Tokenizes the input text input into ids. Appends the appropriate special
    characters to the end of the text to denote end of sentence. Truncate or pad
    the appropriate sequence length.
    """
    # tokenize the text, then truncate sequence to the desired length minus 2 for
    # the 2 special characters
    tokenized_texts = list(map(lambda t: tokenizer.tokenize(t)[:num_embeddings-2], text_list))
    # convert tokenized text into numeric ids for the appropriate LM
    input_ids = [tokenizer.convert_tokens_to_ids(x) for x in tokenized_texts]
    # append special token "<s>" and </s> to end of sentence
    input_ids = [tokenizer.build_inputs_with_special_tokens(x) for x in input_ids]
    # pad sequences
    input_ids = pad_sequences(input_ids, maxlen=num_embeddings, dtype="long", truncating="post", padding="post")
    return input_ids

# BERT
def create_attn_masks(input_ids):
    """
    Create attention masks to tell model whether attention should be applied to
    the input id tokens. Do not want to perform attention on padding tokens.
    """
    # Create attention masks
    attention_masks = []

    # Create a mask of 1s for each token followed by 0s for padding
    for seq in input_ids:
        seq_mask = [float(i>0) for i in seq]
        attention_masks.append(seq_mask)
    return attention_masks

# code for creating parameter table
DD_HP = {"Model": "Deep Dense Model",
          "Neurons per Layer": "50",
          "Number of Layers": "3",
          "Kernel Initializer": "LeCun Normal",
          "Activation Function": "Selu",
          "Regularisation": "Dropout = 0.5",
          "Optimizer": "Adam",
          "Learning Rate": "1e-3",
          "Batch Size" : "2048",
          "Epochs": "200"}

LSTM_HP = {"Model": "LSTM Model",
          "Neurons per Layer": "100, 64, 100",
          "Number of Layers": "3",
          "Kernel Initializer": "Default",
          "Activation Function": "relu",
          "Regularisation": "Dropout = 0.3",
          "Optimizer": "Adam",
          "Learning Rate": "",
          "Batch Size" : "512",
          "Epochs": "6"}

GRU_HP = {"Model": "GRU Model",
          "Neurons per Layer": "100, 64, 100",
          "Number of Layers": "3",
          "Kernel Initializer": "Default",
          "Activation Function": "relu",
          "Regularisation": "Dropout = 0.3",
          "Optimizer": "Adam",
          "Learning Rate": "",
          "Batch Size" : "512",
          "Epochs": "6"}
          
BERT_HP = {"Model": "BERT Model",
          "Neurons per Layer": "768",
          "Number of Layers": "12",
          "Kernel Initializer": "Xavier Normal",
          "Activation Function": "gelu",
          "Regularisation": "Dropout = 0.1",
          "Optimizer": "AdamW",
          "Learning Rate": "2e-5",
          "Batch Size" : "16",
          "Epochs": "1"}

hyp_dict = [DD_HP, LSTM_HP, GRU_HP, BERT_HP]

hyp_df = pd.DataFrame(hyp_dict)
hyp_df

"""# Code - Read Data"""

# Load Data from public google drive URL
train_URL = 'https://drive.google.com/file/d/12U6D9dyz7JVcBQ27T46R8m1rDB0YDoyH/view?usp=sharing'
train_csv = 'https://drive.google.com/uc?export=download&id='+train_URL.split('/')[-2]
test_URL = 'https://drive.google.com/file/d/1Mc6oNhvtPTr8pS7vLrTHkWUR3XDgR-FH/view?usp=sharing'
test_csv = 'https://drive.google.com/uc?export=download&id='+test_URL.split('/')[-2]

"""# Code - Preprocessing

### Base ML Preprocessing
"""

train_base = pd.read_csv(train_csv, dtype={
        "docid":str,
        "publication_date":str,
        "contract_type":str,
        "nature_of_contract":str,
        "country_code":str,
        "country_name":str,
        "sector":str,
        "category":str,
        "value":float,
        "title":str,
        "description":str,
        "awarding_authority":str,
        "complete_entry":str,
        "label":str   
    })

test_base = pd.read_csv(test_csv, dtype={
        "docid":str,
        "publication_date":str,
        "contract_type":str,
        "nature_of_contract":str,
        "country_code":str,
        "country_name":str,
        "sector":str,
        "category":str,
        "value":float,
        "title":str,
        "description":str,
        "awarding_authority":str,
        "complete_entry":str
    })

# drop columns
train_base = train_base.drop(['docid', 'publication_date', 'contract_type', 'nature_of_contract', 'country_code', 'country_name', 'sector', 'value', 'title', "country_code","country_name", "sector", "label", "awarding_authority"], axis=1)
test_base = test_base.drop(['docid', 'publication_date', 'contract_type', 'nature_of_contract', 'country_code', 'country_name', 'sector', 'value', 'title', "country_code","country_name", "sector", "awarding_authority"], axis=1)

# explode cpvs list to lengthen dataset
train_base['category'] = train_base['category'].apply(literal_eval) #convert to list type
train_base = train_base.explode('category')

# encode and bind function
train_base = encode_and_bind(train_base, 'category')
train_base = train_base.drop(['category'], axis=1)

cols_target = ["category_Defence", "category_Education & Culture", "category_Energy & Environment", "category_General", "category_Health & Care", "category_Infrastructure & Construction", "category_Professional Services", "category_Technology & Communications", "category_Transport & Logistics" ]

unlabelled_in_all = train_base[(train_base['category_Defence']!=1) & (train_base['category_Education & Culture']!=1) & (train_base['category_Energy & Environment']!=1) & 
                            (train_base['category_General']!=1) & (train_base['category_Health & Care']!=1) & (train_base['category_Infrastructure & Construction']!=1) & 
                             (train_base['category_Professional Services']!=1) & (train_base['category_Technology & Communications']!=1) & (train_base['category_Transport & Logistics']!=1)]
print('Percentage of unlabelled comments is ', len(unlabelled_in_all)/len(train_base)*100)

# clean the comment_text in train_df [Thanks to Pulkit Jha for the useful pointer.]
train_base['description'] = train_base['description'].map(lambda com : clean_text(com))

# clean the comment_text in test_df [Thanks, Pulkit Jha.]
test_base['description'] = test_base['description'].map(lambda com : clean_text(com))

X_base = train_base.description
test_X_base = test_base.description
print(X_base.shape, test_X_base.shape)

# import and instantiate TfidfVectorizer
vect = TfidfVectorizer(max_features=5000,stop_words='english')
vect

# learn the vocabulary in the training data, then use it to create a document-term matrix
X_dtm = vect.fit_transform(X_base)
# examine the document-term matrix created from X_train
X_dtm

# transform the test data using the earlier fitted vocabulary, into a document-term matrix
test_X_dtm = vect.transform(test_X_base)
# examine the document-term matrix from X_test
test_X_dtm

"""### Deep Dense Pre-Processing

After reading the datasets, the Title column is split in two in order to get an additional feature from that column, the city feature
"""

train_dense = pd.read_csv(train_csv, dtype={
        "docid":str,
        "publication_date":str,
        "contract_type":str,
        "nature_of_contract":str,
        "country_code":str,
        "country_name":str,
        "sector":str,
        "category":str,
        "value":float,
        "title":str,
        "description":str,
        "awarding_authority":str,
        "complete_entry":str,
        "label":str   
    })

test_dense = pd.read_csv(test_csv, dtype={
        "docid":str,
        "publication_date":str,
        "contract_type":str,
        "nature_of_contract":str,
        "country_code":str,
        "country_name":str,
        "sector":str,
        "category":str,
        "value":float,
        "title":str,
        "description":str,
        "awarding_authority":str,
        "complete_entry":str
    })

df = pd.DataFrame(train_dense['title'].astype(str).str.split(':',1).tolist(),columns = ['1','2'])
df1 = pd.DataFrame(test_dense['title'].astype(str).str.split(':',1).tolist(),columns = ['1','2'])

train_dense['title'] = df['2']
test_dense['title'] = df1['2']
train_dense['city'] = df['1']
test_dense['city'] = df1['1']

"""Then, columns that have been considered as not contributing information to the model have been deleted from the two datasets."""

train_dense = train_dense.drop(["publication_date","country_code","country_name", "sector", "label", "value", "description", "awarding_authority"], axis=1)
test_dense = test_dense.drop(["publication_date","country_code","country_name", "sector", "value", "description", "awarding_authority"], axis=1)

"""In the column "nature of contract" there is just one  "Combined" value in the test dataset. No "Combined" values in the training set. 
As it is not possible to delete rows from the test dataset, this data point have been treated as if it was the most common value in this column: work
"""

train_dense['nature_of_contract'].value_counts()

test_dense['nature_of_contract'].value_counts()

test_dense.loc[test_dense['nature_of_contract'].str.contains("combined", na=False),['nature_of_contract']] = 'works'

train = train_dense.copy()
test = test_dense.copy()

"""In the "title" and "city" columns there are a lot of different values. In order not to make a huge dataset when passing the different values of these features to columns, it has been decided to create dummie variables for only the most important ones, and to assign the other ones the value 'other'."""

train['Title'] = 'other'
train.loc[train['title'].str.contains("Construction work", na=False),['Title']] = 'Construction work'
train.loc[train['title'].str.contains("Architectural, construction, engineering and inspection services", na=False),['Title']] = 'Architectural, construction, engineering and inspection services'
train.loc[train['title'].str.contains("Engineering services", na=False),['Title']] = 'Engineering services'
train.loc[train['title'].str.contains("Architectural, engineering and planning services", na=False),['Title']] = 'Architectural, engineering and planning services'
train.loc[train['title'].str.contains("Railway construction works", na=False),['Title']] = 'Railway construction works'
train.loc[train['title'].str.contains("Pharmaceutical products", na=False),['Title']] = 'Pharmaceutical products'
train.loc[train['title'].str.contains("IT services: consulting, software development, Internet and support", na=False),['Title']] = 'IT services: consulting, software development, Internet and support'
train.loc[train['title'].str.contains("Building-cleaning services", na=False),['Title']] = 'Building-cleaning services'
train.loc[train['title'].str.contains("Metalworking", na=False),['Title']] = 'Metalworking'
train.loc[train['title'].str.contains("Architectural and related services", na=False),['Title']] = 'Architectural and related services'
train.loc[train['title'].str.contains("Firefighting vehicles", na=False),['Title']] = 'Firefighting vehicles'
train.loc[train['title'].str.contains("Structural shell work", na=False),['Title']] = 'Structural shell work'
train = pd.get_dummies(data = train, columns=['Title'])

test['Title'] = 'other'
test.loc[test['title'].str.contains("Construction work", na=False),['Title']] = 'Construction work'
test.loc[test['title'].str.contains("Architectural, construction, engineering and inspection services", na=False),['Title']] = 'Architectural, construction, engineering and inspection services'
test.loc[test['title'].str.contains("Engineering services", na=False),['Title']] = 'Engineering services'
test.loc[test['title'].str.contains("Architectural, engineering and planning services", na=False),['Title']] = 'Architectural, engineering and planning services'
test.loc[test['title'].str.contains("Railway construction works", na=False),['Title']] = 'Railway construction works'
test.loc[test['title'].str.contains("Pharmaceutical products", na=False),['Title']] = 'Pharmaceutical products'
test.loc[test['title'].str.contains("IT services: consulting, software development, Internet and support", na=False),['Title']] = 'IT services: consulting, software development, Internet and support'
test.loc[test['title'].str.contains("Building-cleaning services", na=False),['Title']] = 'Building-cleaning services'
test.loc[test['title'].str.contains("Metalworking", na=False),['Title']] = 'Metalworking'
test.loc[test['title'].str.contains("Architectural and related services", na=False),['Title']] = 'Architectural and related services'
test.loc[test['title'].str.contains("Firefighting vehicles", na=False),['Title']] = 'Firefighting vehicles'
test.loc[test['title'].str.contains("Structural shell work", na=False),['Title']] = 'Structural shell work'
test = pd.get_dummies(data = test, columns=['Title'])

train['general_city'] = 'other'
train.loc[train['city'].str.contains("Germany-Frankfurt-on-Main", na=False),['general_city']] = 'Germany-Frankfurt-on-Main'
train.loc[train['city'].str.contains("Germany-Berlin", na=False),['general_city']] = 'Germany-Berlin'
train.loc[train['city'].str.contains("Germany-Munich", na=False),['general_city']] = 'Germany-Munich'
train.loc[train['city'].str.contains("Germany-Hamburg", na=False),['general_city']] = 'Germany-Hamburg'
train.loc[train['city'].str.contains("Germany-Dresden", na=False),['general_city']] = 'Germany-Dresden'
train.loc[train['city'].str.contains("Germany-Düsseldorf", na=False),['general_city']] = 'Germany-Düsseldorf'
train.loc[train['city'].str.contains("Germany-Bonn", na=False),['general_city']] = 'Germany-Bonn'
train.loc[train['city'].str.contains("Germany-Stuttgart", na=False),['general_city']] = 'Germany-Stuttgart'
train.loc[train['city'].str.contains("Germany-Hanover", na=False),['general_city']] = 'Germany-Hanover'
train.loc[train['city'].str.contains("Germany-Cologne", na=False),['general_city']] = 'Germany-Cologne'
train.loc[train['city'].str.contains("Germany-Nuremberg", na=False),['general_city']] = 'Germany-Nuremberg'
train.loc[train['city'].str.contains("Germany-Leipzig", na=False),['general_city']] = 'Germany-Leipzig'
train.loc[train['city'].str.contains("Germany-Karlsruhe", na=False),['general_city']] = 'Germany-Karlsruhe'
train = pd.get_dummies(data = train, columns=['general_city'])

test['general_city'] = 'other'
test.loc[test['city'].str.contains("Germany-Frankfurt-on-Main", na=False),['general_city']] = 'Germany-Frankfurt-on-Main'
test.loc[test['city'].str.contains("Germany-Berlin", na=False),['general_city']] = 'Germany-Berlin'
test.loc[test['city'].str.contains("Germany-Munich", na=False),['general_city']] = 'Germany-Munich'
test.loc[test['city'].str.contains("Germany-Hamburg", na=False),['general_city']] = 'Germany-Hamburg'
test.loc[test['city'].str.contains("Germany-Dresden", na=False),['general_city']] = 'Germany-Dresden'
test.loc[test['city'].str.contains("Germany-Düsseldorf", na=False),['general_city']] = 'Germany-Düsseldorf'
test.loc[test['city'].str.contains("Germany-Bonn", na=False),['general_city']] = 'Germany-Bonn'
test.loc[test['city'].str.contains("Germany-Stuttgart", na=False),['general_city']] = 'Germany-Stuttgart'
test.loc[test['city'].str.contains("Germany-Hanover", na=False),['general_city']] = 'Germany-Hanover'
test.loc[test['city'].str.contains("Germany-Cologne", na=False),['general_city']] = 'Germany-Cologne'
test.loc[test['city'].str.contains("Germany-Nuremberg", na=False),['general_city']] = 'Germany-Nuremberg'
test.loc[test['city'].str.contains("Germany-Leipzig", na=False),['general_city']] = 'Germany-Leipzig'
test.loc[test['city'].str.contains("Germany-Karlsruhe", na=False),['general_city']] = 'Germany-Karlsruhe'
test = pd.get_dummies(data = test, columns=['general_city'])

train = train.drop(["general_city_other","Title_other","city", "title"], axis=1)
test = test.drop(["general_city_other","Title_other","city", "title"], axis=1)

"""Building the dummies"""

train = encode_and_bind(train, 'contract_type')
train = encode_and_bind(train, 'nature_of_contract')
test = encode_and_bind(test, 'contract_type')
test = encode_and_bind(test, 'nature_of_contract')

train = train.drop(["contract_type","nature_of_contract"], axis=1)
test = test.drop(["contract_type","nature_of_contract"], axis=1)

"""In the "category" column each data point can have more than one category, so the MultiLabelBinarizer is used to create the dummy variables. The train1 dataframe is created with the dummie categories which afterwards is merged with the dataframe that contains the features"""

train['category'] = train['category'].apply(literal_eval) #convert to list type

mlb = MultiLabelBinarizer()
train1 = pd.DataFrame(mlb.fit_transform(train['category']),columns=mlb.classes_)

train=pd.merge(train, train1, left_index=True, right_index=True)

train=train.drop(['category'],axis=1)

"""The training data is separated into train, validation and test set in order to see the performance of the model. """

train_df, test_df = train_test_split(train, test_size=0.2)
train_df, val_df = train_test_split(train_df, test_size=0.2)

"""The labels are converted to array variables. And the features are scaled."""

train_labels=np.c_[train_df['Defence'],
                   train_df['Education & Culture'],
                   train_df['Energy & Environment'],
                   train_df['General'],
                   train_df['Health & Care'],
                   train_df['Infrastructure & Construction'],
                   train_df['Professional Services'],
                   train_df['Technology & Communications'],
                   train_df['Transport & Logistics']]

train_labels = np.asarray(train_labels).astype('float32').reshape((-1,9))

bool_train_labels = train_labels != 0

val_labels = np.c_[val_df['Defence'],
                   val_df['Education & Culture'],
                   val_df['Energy & Environment'],
                   val_df['General'],
                   val_df['Health & Care'],
                   val_df['Infrastructure & Construction'],
                   val_df['Professional Services'],
                   val_df['Technology & Communications'],
                   val_df['Transport & Logistics']]

val_labels = np.asarray(val_labels).astype('float32').reshape((-1,9))

test_labels = np.c_[test_df['Defence'],
                   test_df['Education & Culture'],
                   test_df['Energy & Environment'],
                   test_df['General'],
                   test_df['Health & Care'],
                   test_df['Infrastructure & Construction'],
                   test_df['Professional Services'],
                   test_df['Technology & Communications'],
                   test_df['Transport & Logistics']]

test_labels = np.asarray(test_labels).astype('float32').reshape((-1,9))

train_labels_df = train_df[['Defence',
                         'Education & Culture',
                         'Energy & Environment',
                         'General',
                         'Health & Care',
                         'Infrastructure & Construction',
                         'Professional Services',
                         'Technology & Communications',
                         'Transport & Logistics']].copy()

train_features=train_df.iloc[:,1:31]
val_features=val_df.iloc[:,1:31]
test_features=test_df.iloc[:,1:31]

real_test_docid=test.iloc[:,0]

real_test_features=test.iloc[:,1:31]

scaler = StandardScaler()
train_features = scaler.fit_transform(train_features)
val_features = scaler.transform(val_features)
test_features = scaler.transform(test_features)

# assign data for dense model to run
train_features_dense = train_features.copy()
val_features_dense = val_features.copy()
test_features_dense = test_features.copy()

train_labels_dense = train_labels_df.copy()
val_labels_dense = val_labels.copy()
test_labels_dense = test_labels.copy()

"""RandomizedSearchCV for the most suitable hyperparameters"""

keras.backend.clear_session()
np.random.seed(42)

def build_model(n_hidden=1, n_neurons=30, learning_rate=3e-3, input_shape=train_features.shape[1:]):
    model = keras.models.Sequential()
    model.add(keras.layers.InputLayer(input_shape=input_shape))
    for layer in range(n_hidden):
        model.add(keras.layers.Dense(n_neurons, activation="selu",kernel_initializer="lecun_normal"))
    model.add(keras.layers.Dense(9, activation="sigmoid"))
    optimizer = keras.optimizers.SGD(lr=learning_rate, momentum=0.9, decay=0.01)
    model.compile(loss="binary_crossentropy", optimizer=optimizer)
    return model

keras_reg = keras.wrappers.scikit_learn.KerasRegressor(build_model)

"""
param_distribs = {
    "n_hidden": [3,4,5,6,7,8],
    "n_neurons": np.arange(1, 100),
    "learning_rate": [3e-2,3e-3,3e-4],
}

rnd_search_cv = RandomizedSearchCV(keras_reg, param_distribs, n_iter=10, cv=3, verbose=2)
rnd_search_cv.fit(train_features, train_labels, epochs=100,
                  validation_data=(val_features, val_labels),
                  callbacks=[keras.callbacks.EarlyStopping(patience=10)])
"""

#rnd_search_cv.best_params_

"""Dense deep learning: 6 layers, 89 neurons --> 0.399 score in Kaggle

### LSTM and GRU preprocessing

Read the dataset
"""

train_nn = pd.read_csv(train_csv,  dtype={
        "docid":str,
        "publication_date":str,
        "contract_type":str,
        "nature_of_contract":str,
        "country_code":str,
        "country_name":str,
        "sector":str,
        "category":str,
        "value":float,
        "title":str,
        "description":str,
        "awarding_authority":str,
        "complete_entry":str,
        "label":str   
    })

test_nn = pd.read_csv(test_csv,  dtype={
        "docid":str,
        "publication_date":str,
        "contract_type":str,
        "nature_of_contract":str,
        "country_code":str,
        "country_name":str,
        "sector":str,
        "category":str,
        "value":float,
        "title":str,
        "description":str,
        "awarding_authority":str,
        "complete_entry":str,
        "label":str   
    })

"""Drop the columns that are not relevant for this model"""

train_nn = train_nn.drop(["publication_date","country_code","country_name", "sector", "label", "value"], axis=1)
test_nn = test_nn.drop(["publication_date","country_code","country_name", "sector", "value"], axis=1)

"""Take the column "docid" to use it for the predictions of Kaggle"""

real_test_docid=test_nn['docid']

"""Convert the format of the columns that are going to use to string"""

train_nn['contract_type']=train_nn['contract_type'].astype(str)
train_nn['nature_of_contract']=train_nn['nature_of_contract'].astype(str)
train_nn['awarding_authority']=train_nn['awarding_authority'].astype(str)
test_nn['contract_type']=test_nn['contract_type'].astype(str)
test_nn['nature_of_contract']=test_nn['nature_of_contract'].astype(str)
test_nn['awarding_authority']=test_nn['awarding_authority'].astype(str)

"""Add all the strings that are going to use to a column called "features" and drop the rest of the columns"""

train_nn['features']=train_nn[['contract_type','nature_of_contract','title','awarding_authority','description']].agg(' '.join,axis=1)
test_nn['features']=test_nn[['contract_type','nature_of_contract','title','awarding_authority','description']].agg(' '.join,axis=1)

train_nn=train_nn.drop(['contract_type','nature_of_contract','title','awarding_authority','description'], axis=1)
test_nn=test_nn.drop(['contract_type','nature_of_contract','title','awarding_authority','description'], axis=1)

"""Apply the MultiLabelBinarizer to the category column in which there are all the classes"""

train_nn['category'] = train_nn['category'].apply(literal_eval) #convert to list type

mlb = MultiLabelBinarizer()
train_nn1 = pd.DataFrame(mlb.fit_transform(train_nn['category']),columns=mlb.classes_)
train_nn=pd.merge(train_nn, train_nn1, left_index=True, right_index=True)
train_nn = train_nn.drop(["category"], axis=1)

"""Rename the columns"""

train_nn=train_nn.rename(columns={      "Education & Culture":'Education', 
                                  "Energy & Environment":'Energy',
                                  "Health & Care":'Health',
                                  "Infrastructure & Construction":'Infrastructure',
                                  "Professional Services":'Professional',
                                  "Technology & Communications":'Technology',
                                  "Transport & Logistics":'Transport'})

"""Create a dataframe with the different classes called "train_labels" and a list called "train_labels_names" for further use"""

train_labels=train_nn[['Defence','Education','Energy','General','Health','Infrastructure','Professional','Technology','Transport']]

train_labels_names=['Defence','Education','Energy','General','Health','Infrastructure','Professional','Technology','Transport']

"""Data cleaning using nltk package: remove capital letters, punctuation marks and any other symbol that does not provide information. Stopwords have also been deleted and lemmatisation has been applied to the dataset"""

nltk.download('all')

stop_words = stopwords.words("german")
lemmatizer = WordNetLemmatizer()

train_nn['features'] = train_nn['features'].map(lambda x: cleaning(x))
train_nn['features'] = train_nn['features'].map(lambda x: clean_text_nn(x))
test_nn['features'] = test_nn['features'].map(lambda x: cleaning(x))
test_nn['features'] = test_nn['features'].map(lambda x: clean_text_nn(x))

"""A Tokenizer instance is fitted "fit_on_texts" to the corpus creating a vocabulary index based on word frequency. Every word is mapped to an index, so every word gets a unique integer value, lower integer means more frequent words. The size of words to keep is defined by the num_words parameter, in this case, "vocabulary_size". Only the most common words will be kept.

The sentences from the input are then mapped to integers using the "tokenizer.texts_to_sequences" method.
"""

vocabulary_size = 20000
tokenizer = Tokenizer(num_words=vocabulary_size)
tokenizer.fit_on_texts(train_nn['features'])
sequences = tokenizer.texts_to_sequences(train_nn['features'])

tokenizer1 = Tokenizer(num_words=vocabulary_size)
tokenizer1.fit_on_texts(test_nn['features'])
sequences1 = tokenizer1.texts_to_sequences(test_nn['features'])

"""Finally, in order to create embeddings, all of the sentences need to be of same length. Therefore, the "pad_sequences" is used to pad each sentence with zero."""

MAXLEN = 500 # In our case the input sequences are words and we have approximately 6000 words per instance. However, a reasonable limit of 250-500 max sequence length is often used in practice with large LSTM models.
X_nn = pad_sequences(sequences, maxlen=MAXLEN)
y_nn = train_nn[train_labels_names]

real_test_features=pad_sequences(sequences1, maxlen=MAXLEN)

"""### BERT Preprocessing"""

train = pd.read_csv(train_csv,  dtype={
        "docid":str,
        "publication_date":str,
        "contract_type":str,
        "nature_of_contract":str,
        "country_code":str,
        "country_name":str,
        "sector":str,
        "category":str,
        "value":float,
        "title":str,
        "description":str,
        "awarding_authority":str,
        "complete_entry":str,
        "label":str   
    })

test = pd.read_csv(test_csv,  dtype={
        "docid":str,
        "publication_date":str,
        "contract_type":str,
        "nature_of_contract":str,
        "country_code":str,
        "country_name":str,
        "sector":str,
        "category":str,
        "value":float,
        "title":str,
        "description":str,
        "awarding_authority":str,
        "complete_entry":str,
        "label":str   
    })

#drop columns
train = train.drop(["publication_date","country_code","country_name", "sector", "label", "value"], axis=1)
test = test.drop(["publication_date","country_code","country_name", "sector", "value"], axis=1)

#store docic
real_test_docid=test['docid']

#convert to list type
train['category'] = train['category'].apply(literal_eval) 

#convert features to string
train['contract_type']=train['contract_type'].astype(str)
train['nature_of_contract']=train['nature_of_contract'].astype(str)
train['awarding_authority']=train['awarding_authority'].astype(str)

test['contract_type']=test['contract_type'].astype(str)
test['nature_of_contract']=test['nature_of_contract'].astype(str)
test['awarding_authority']=test['awarding_authority'].astype(str)

#create one variable text from string features
train['text']=train[['contract_type','nature_of_contract','title','awarding_authority','description']].agg(' '.join,axis=1)
test['text']=test[['contract_type','nature_of_contract','title','awarding_authority','description']].agg(' '.join,axis=1)

#drop overlapping features
train=train.drop(['contract_type','nature_of_contract','title','awarding_authority','description'], axis=1)
test=test.drop(['contract_type','nature_of_contract','title','awarding_authority','description'], axis=1)

#multilabel binarizer to create 1s and 0s for each label
from sklearn.preprocessing import MultiLabelBinarizer
mlb = MultiLabelBinarizer()
train1 = pd.DataFrame(mlb.fit_transform(train['category']),columns=mlb.classes_)
train=pd.merge(train, train1, left_index=True, right_index=True)
train = train.drop(["category"], axis=1)

# rename columns for ease of use
train=train.rename(columns={      "Education & Culture":'Education', 
                                  "Energy & Environment":'Energy',
                                  "Health & Care":'Health',
                                  "Infrastructure & Construction":'Infrastructure',
                                  "Professional Services":'Professional',
                                  "Technology & Communications":'Technology',
                                  "Transport & Logistics":'Transport'})

# store feature labels
train_labels=train[['Defence','Education','Energy','General','Health','Infrastructure','Professional','Technology','Transport']]
train_labels_names=['Defence','Education','Energy','General','Health','Infrastructure','Professional','Technology','Transport']

# download nltk
nltk.download('all')
stop_words = stopwords.words("german")
lemmatizer = WordNetLemmatizer()

#run text cleaning functions
train['text'] = train['text'].map(lambda x: cleaning(x))
train['text'] = train['text'].map(lambda x: clean_text(x))
test['text'] = test['text'].map(lambda x: cleaning(x))
test['text'] = test['text'].map(lambda x: clean_text(x))

# Run BERT Tokenizer
tokenizer = BertTokenizer.from_pretrained('bert-base-multilingual-cased', do_lower_case=True)

#convert text to values
train_text_list = train["text"].values
test_text_list = test["text"].values

#plot train text length
plot_sentence_embeddings_length(train_text_list, tokenizer)

# create input id tokens
train_input_ids = tokenize_inputs(train_text_list, tokenizer, num_embeddings=250)
test_input_ids = tokenize_inputs(test_text_list, tokenizer, num_embeddings=250)

# create attention masks
train_attention_masks = create_attn_masks(train_input_ids)
test_attention_masks = create_attn_masks(test_input_ids)

# add input ids and attention masks to the dataframe
train["features"] = train_input_ids.tolist()
train["masks"] = train_attention_masks

test["features"] = test_input_ids.tolist()
test["masks"] = test_attention_masks

# train valid split - train_bert and train_valid will be used in the modelling section
train_bert, valid_bert = train_test_split(train, test_size=0.2, random_state=42)

"""# Code - Models

## Basic Machine Learning - Logistic Regression
"""

logreg = LogisticRegression(C=12.0, max_iter=1000, )

submission_binary = pd.DataFrame()

for label in cols_target:
    print('... Processing {}'.format(label))
    y = train_base[label]
    # train the model using X_dtm & y
    logreg.fit(X_dtm, y)
    # compute the training accuracy
    y_pred_X = logreg.predict(X_dtm)
    print('Training accuracy is {}'.format(accuracy_score(y, y_pred_X)))
    # compute the predicted probabilities for X_test_dtm
    test_y_prob = logreg.predict_proba(test_X_dtm)[:,1]
    submission_binary[label] = test_y_prob

"""**Kaggle Predictions**"""

submission_binary = submission_binary.round(0)

df_strings=pd.DataFrame(submission_binary,columns=['category_Defence','category_Education & Culture',
                                                  'category_Energy & Environment','category_General',
                                                  'category_Health & Care',
                                                  'category_Infrastructure & Construction',
                                                  'category_Professional Services',
                                                  'category_Technology & Communications',
                                                  'category_Transport & Logistics'])

df_strings['category_Defence']=df_strings['category_Defence'].astype(int)
df_strings['category_Education & Culture']=df_strings['category_Education & Culture'].astype(int)
df_strings['category_Energy & Environment']=df_strings['category_Energy & Environment'].astype(int)
df_strings['category_General']=df_strings['category_General'].astype(int)
df_strings['category_Health & Care']=df_strings['category_Health & Care'].astype(int)
df_strings['category_Infrastructure & Construction']=df_strings['category_Infrastructure & Construction'].astype(int)
df_strings['category_Professional Services']=df_strings['category_Professional Services'].astype(int)
df_strings['category_Technology & Communications']=df_strings['category_Technology & Communications'].astype(int)
df_strings['category_Transport & Logistics']=df_strings['category_Transport & Logistics'].astype(int)

df_strings['category_Defence']=df_strings['category_Defence'].astype(str)
df_strings['category_Education & Culture']=df_strings['category_Education & Culture'].astype(str)
df_strings['category_Energy & Environment']=df_strings['category_Energy & Environment'].astype(str)
df_strings['category_General']=df_strings['category_General'].astype(str)
df_strings['category_Health & Care']=df_strings['category_Health & Care'].astype(str)
df_strings['category_Infrastructure & Construction']=df_strings['category_Infrastructure & Construction'].astype(str)
df_strings['category_Professional Services']=df_strings['category_Professional Services'].astype(str)
df_strings['category_Technology & Communications']=df_strings['category_Technology & Communications'].astype(str)
df_strings['category_Transport & Logistics']=df_strings['category_Transport & Logistics'].astype(str)

df_strings['label']=df_strings[['category_Defence','category_Education & Culture','category_Energy & Environment',
                               'category_General','category_Health & Care','category_Infrastructure & Construction',
                               'category_Professional Services','category_Technology & Communications',
                               'category_Transport & Logistics']].agg(''.join,axis=1)

df_strings = df_strings.drop(['category_Defence','category_Education & Culture','category_Energy & Environment',
                               'category_General','category_Health & Care','category_Infrastructure & Construction',
                               'category_Professional Services','category_Technology & Communications',
                               'category_Transport & Logistics'], axis=1)

test_data = test_base.copy()
output=pd.merge(test_data, df_strings, left_index=True, right_index=True)
output

#output.to_csv('submission_multi_logistic.csv',index=False)

"""## Dense Deep Network (3 layer)"""

METRICS = [
      keras.metrics.TruePositives(name='tp'),
      keras.metrics.FalsePositives(name='fp'),
      keras.metrics.TrueNegatives(name='tn'),
      keras.metrics.FalseNegatives(name='fn'), 
      keras.metrics.BinaryAccuracy(name='accuracy'),
      keras.metrics.Precision(name='precision'),
      keras.metrics.Recall(name='recall'),
      keras.metrics.AUC(name='auc')
]

EPOCHS = 200
BATCH_SIZE = 2048

early_stopping = tf.keras.callbacks.EarlyStopping(
    monitor='val_auc', 
    verbose=1,
    patience=10,
    mode='max',
    restore_best_weights=True)

def three_layer_model(metrics=METRICS, output_bias=None):
  if output_bias is not None:
    output_bias = tf.keras.initializers.Constant(output_bias)
  model = keras.Sequential([
      keras.layers.Dense(50, activation='selu', input_shape=(train_features.shape[-1],), kernel_initializer="lecun_normal"),
      keras.layers.Dropout(0.5),      
      keras.layers.Dense(50, activation='selu', kernel_initializer="lecun_normal"),
      keras.layers.Dropout(0.5),   
      keras.layers.Dense(50, activation='selu', kernel_initializer="lecun_normal"),
      keras.layers.Dropout(0.5),               
      keras.layers.Dense(9, activation='sigmoid',
                         bias_initializer=output_bias),
  ])    

  model.compile(
      optimizer=keras.optimizers.Adam(lr=1e-3),
      loss=keras.losses.BinaryCrossentropy(),
      metrics=metrics)

  return model

print(tf.__version__)

import tensorflow as tf
from keras import backend as K
model=three_layer_model()
history = model.fit(
    train_features_dense, train_labels_dense,
    steps_per_epoch=20,
    epochs=EPOCHS,
    callbacks=[early_stopping],
    validation_data=(val_features_dense,val_labels_dense))

"""FINAL EVALUATION"""

test_predictions = model.predict(test_features_dense)
test_predictions=test_predictions.round(0)

"""It can be seen in the confusion matrix that the model only predicts some of the classes, which just happen to coincide with the classes that have the most instances in the training data."""

multilabel_confusion_matrix(test_labels_dense, test_predictions)

Evaluate(three_layer_model)

from sklearn.metrics import classification_report
print(classification_report(test_labels_dense, test_predictions))

#generate predictions
test_predictions_kaggle=model.predict(test_features_dense)
test_predictions_kaggle=test_predictions_kaggle.round(0)

"""## LSTM Network"""

# split data into train and test
X_train, X_test, y_train, y_test = train_test_split(X_nn, y_nn, test_size=0.15, random_state = 42)

# In our case the input sequences are words and we have approximately 6000 words per instance. However, a reasonable limit of 250-500 max sequence length is often used in practice with large LSTM models.
MAXLEN = 500 

# For building this model we'll use the Keras functional API and not the common used Sequential() model. This is because with this API it's possible to build more complex models, such as multi-output and multi-inputs problems.
# We will be training our own embeddings using Keras Embedding Layer.
main_input = Input(shape=(MAXLEN,), dtype='int32', name='main_input')
x = Embedding(vocabulary_size, 100, input_length=MAXLEN)(main_input)
x = Dropout(0.3)(x)
x = Conv1D(64, 5, activation='relu')(x) # A Convolutional layer was added before the LSTM in order to speed-up the training time.
x = MaxPooling1D(pool_size=4)(x)
x = LSTM(100)(x)
x = Dropout(0.3)(x)

# A Dense layer is created for each of ouput. The corresponding metrics and losses for each output will also be stored into dictionaries.
output_array = []
metrics_array = {}
loss_array = {}
# The code below iterates through each of the output binary columns and creates a dense layer.
for i, dense_layer in enumerate(train_labels_names):
    name = f'binary_output_{i}'
    binary_output = Dense(1, activation='sigmoid', name=name)(x)
    output_array.append(binary_output)
    metrics_array[name] = 'binary_accuracy'
    loss_array[name] = 'binary_crossentropy'

y_train_output = []
for col in train_labels_names:
    y_train_output.append(y_train[col])

# For each output we define the weight for each class in a dictionary format (class 5 is different from the rest)
weight_binary = {0: 0.5, 1: 10} # these values are obtained through calculations
weight_binary5={0:1,1:0.8} # these values are obtained through calculations
classes_weights = {}
classes_weights[0]=weight_binary
classes_weights[1]=weight_binary
classes_weights[2]=weight_binary
classes_weights[3]=weight_binary
classes_weights[4]=weight_binary
classes_weights[5]=weight_binary5
classes_weights[6]=weight_binary
classes_weights[7]=weight_binary
classes_weights[8]=weight_binary

# Implement early stopping to help limit overfitting
early_stopping = tf.keras.callbacks.EarlyStopping(
    monitor='val_loss', 
    verbose=1,
    patience=10,
    mode='max',
    restore_best_weights=True)

"""![descargar.png](data:image/png;base64,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)

![descargar (1).png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmcAAAHwCAYAAADjOch3AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADh0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uMy4yLjIsIGh0dHA6Ly9tYXRwbG90bGliLm9yZy+WH4yJAAAgAElEQVR4nOzdeXxV1b3+8c83cwJhCoEECPNMmMMkzooQVFBQUByrFcV6295af9VWa6ttr52stw441BlFcZ4AURS1AkKYE2YQSBjCDAEyZ/3+2GkvRYQEcrLPOXnerxevnpy99zlP/IM+7LXXWuacQ0RERESCQ4TfAURERETk/6iciYiIiAQRlTMRERGRIKJyJiIiIhJEVM5EREREgojKmYiIiEgQUTkTkTrNzF4ws99V8dxNZnbh6X6OiMiJqJyJiIiIBBGVMxEREZEgonImIkGvcjjxLjNbbmaHzexZM2tuZjPMrMDMPjWzxkedP8rMcsxsv5nNMbNuRx3ra2aLK697HYg75rsuMbOlldfONbNep5j5FjNbb2Z7zex9M2tR+b6Z2d/MbKeZHTSzFWaWXnlspJmtrMy21cx+fkr/wUQkpKmciUioGAsMAzoDlwIzgF8CyXh/l/0YwMw6A1OBn1Yemw58YGYxZhYDvAu8DDQB3qj8XCqv7Qs8B9wKJAFPAe+bWWx1gprZ+cD/AOOAVGAz8Frl4YuAsyt/j4aV5+ypPPYscKtzLhFIBz6rzveKSHhQORORUPGocy7fObcV+Ar4xjm3xDlXBLwD9K08bzzwkXPuE+dcKfAXIB44AxgMRAOPOOdKnXNvAguP+o6JwFPOuW+cc+XOuReB4srrquMa4Dnn3GLnXDFwDzDEzNoCpUAi0BUw59wq59z2yutKge5m1sA5t885t7ia3ysiYUDlTERCRf5RrwuP83P9ytct8O5UAeCcqwBygZaVx7Y659xR124+6nUb4M7KIc39ZrYfSKu8rjqOzXAI7+5YS+fcZ8BjwOPATjN72swaVJ46FhgJbDazL8xsSDW/V0TCgMqZiISbbXglC/Ce8cIrWFuB7UDLyvf+pfVRr3OB3zvnGh31J8E5N/U0M9TDGybdCuCc+7tzrj/QHW94867K9xc650YDzfCGX6dV83tFJAyonIlIuJkGXGxmF5hZNHAn3tDkXGAeUAb82MyizWwMMPCoa58BbjOzQZUP7tczs4vNLLGaGaYCPzCzPpXPq/0Bbxh2k5kNqPz8aOAwUARUVD4Td42ZNawcjj0IVJzGfwcRCVEqZyISVpxza4BrgUeB3XiTBy51zpU450qAMcCNwF6859PePuraLOAWvGHHfcD6ynOrm+FT4D7gLby7dR2AqyoPN8Argfvwhj73AH+uPHYdsMnMDgK34T27JiJ1jP3noxciIiIi4ifdORMREREJIipnIiIiIkFE5UxEREQkiKiciYiIiAQRlTMRERGRIBLld4Ca0rRpU9e2bVu/Y4iIiIic1KJFi3Y755KPdyxsylnbtm3JysryO4aIiIjISZnZ5u87FtBhTTMbYWZrzGy9md19nONnm9liMyszsyuOc7yBmeWZ2WOBzCkiIiISLAJWzswsEm9j30y8/eOuNrPux5y2BW/17Ve/52MeBL4MVEYRERGRYBPIO2cDgfXOuY2VW6a8Bow++gTn3Cbn3HKOs3+cmfUHmgOzAphRREREJKgE8pmzlkDuUT/nAYOqcqGZRQB/xdsf78JTDVBaWkpeXh5FRUWn+hEhIy4ujlatWhEdHe13FBERETkNwToh4HZgunMuz8y+9yQzmwhMBGjduvV3jufl5ZGYmEjbtm050eeEOucce/bsIS8vj3bt2vkdR0RERE5DIIc1twJpR/3cqvK9qhgC3GFmm4C/ANeb2UPHnuSce9o5l+Gcy0hO/u5s1KKiIpKSksK6mAGYGUlJSXXiDqGIiEi4C+Sds4VAJzNrh1fKrgImVOVC59w1/3ptZjcCGc6578z2rIpwL2b/Uld+TxERkXAXsDtnzrky4A7gY2AVMM05l2NmD5jZKAAzG2BmecCVwFNmlhOoPH7Zv38/TzzxRLWvGzlyJPv37w9AIhEREQlm5pzzO0ONyMjIcMcuQrtq1Sq6devmUyLPpk2buOSSS8jOzv6P98vKyoiKqtkbl8Hw+4qIiMjJmdki51zG8Y4F64SAsHH33XezYcMG+vTpQ3R0NHFxcTRu3JjVq1ezdu1aLrvsMnJzcykqKuInP/kJEydOBP5vx4NDhw6RmZnJmWeeydy5c2nZsiXvvfce8fHxPv9mIiIiEgh1ppz99oMcVm47WKOf2b1FA+6/tMcJz3nooYfIzs5m6dKlzJkzh4svvpjs7Ox/z6p87rnnaNKkCYWFhQwYMICxY8eSlJT0H5+xbt06pk6dyjPPPMO4ceN46623uPbaa2v0dxEREZHgUGfKWbAYOHDgfyx38fe//5133nkHgNzcXNatW/edctauXTv69OkDQP/+/dm0aVOt5RUREZHaVWfK2cnucNWWevXq/fv1nDlz+PTTT5k3bx4JCQmce+65x10OIzY29t+vIyMjKSwsrJWsIiIiUvsCuvG5QGJiIgUFBcc9duDAARo3bkxCQgKrV69m/vz5tZxOREREgk2duXPml6SkJIYOHUp6ejrx8fE0b97838dGjBjBk08+Sbdu3ejSpQuDBw/2MamIiIgEAy2lEUbq2u8rIiISqk60lIaGNauhvMJRVl7hdwwREREJYypnVVRR4Vi94yC7DhX7HUVERETCmMpZFUVEGAkxURwoLCVchoJFREQk+KicVUPD+ChKyiooKi33O4qIiIiEKZWzamgQF41hHCgs8zuKiIiIhCmVs2qIioygXmykhjZFREQkYFTOqqlhfDTFZeUUl1Vt1ub+/ft54oknTum7HnnkEY4cOXJK14qIiEhoUjmrpgbx0QAcKCyt0vkqZyIiIlId2iGgmqIjI6hXOWuzeYO4k55/9913s2HDBvr06cOwYcNo1qwZ06ZNo7i4mMsvv5zf/va3HD58mHHjxpGXl0d5eTn33Xcf+fn5bNu2jfPOO4+mTZvy+eef18JvJyIiIn6rO+Vsxt2wY0WNfFTr8gqKyyooS+tN1MV/OuG5Dz30ENnZ2SxdupRZs2bx5ptvsmDBApxzjBo1ii+//JJdu3bRokULPvroI8Dbc7Nhw4Y8/PDDfP755zRt2rRGcouIiEjw07DmKYiMMABKqrlbwKxZs5g1axZ9+/alX79+rF69mnXr1tGzZ08++eQTfvGLX/DVV1/RsGHDQMQWERGREFB37pxlPlRjHxUB7Nh5COccnapxnXOOe+65h1tvvfU7xxYvXsz06dO59957ueCCC/j1r39dY3lFREQkdOjO2SlqGB9FYWk5JWUnXpA2MTGRgoICAIYPH85zzz3HoUOHANi6dSs7d+5k27ZtJCQkcO2113LXXXexePHi71wrIiIidUPduXNWwxrER7P9QBEHCstIToz83vOSkpIYOnQo6enpZGZmMmHCBIYMGQJA/fr1mTJlCuvXr+euu+4iIiKC6OhoJk+eDMDEiRMZMWIELVq00IQAERGROsLCZTHVjIwMl5WV9R/vrVq1im7dugXsO9flF2BmdGxWP2DfUR2B/n1FRESkZpjZIudcxvGOaVjzNDSMj+ZISRmlVVyQVkRERORkVM5Ow78XpC2q2oK0IiIiIiejcnYa4qIjiYuOrPJuASIiIiInE/blLNDP1DWIj+ZIcRml1VzzrKaFy7ODIiIidV1Yl7O4uDj27NkT0OLSMC4aBxz08e6Zc449e/YQF3fy7aREREQkuIX1UhqtWrUiLy+PXbt2BfR79h4s4sB2o2n92IB+z4nExcXRqlUr375fREREakZYl7Po6GjatWsX8O95f+Zqnv5yI1m/upDG9WIC/n0iIiISvsJ6WLO2ZKanUF7h+GRVvt9RREREJMSpnNWAni0b0rJRPDOzd/gdRUREREKcylkNMDMy01P4at0uDmrNMxERETkNKmc1JLNnKqXljs9W7fQ7ioiIiIQwlbMa0jetEc0bxDIje7vfUURERCSEqZzVkIgIY0SPFOas2cXh4jK/44iIiEiIUjmrQZk9Uykuq2DOmsCuqyYiIiLhS+WsBg1o24Sm9WM0tCkiIiKnTOWsBkVGGMO6p/DZ6p0UlZb7HUdERERCkMpZDRvZM4UjJeV8uVZDmyIiIlJ9Kmc1bHD7JBrGRzNDC9KKiIjIKVA5q2HRkREM696cT1flU1JW4XccERERCTEqZwEwsmcKBUVlfL1ht99RREREJMSonAXA0I5NSYyNYsYKzdoUERGR6lE5C4DYqEgu6NaMT1bmU1auoU0RERGpOpWzABmRnsq+I6V88+1ev6OIiIhICFE5C5BzOicTHx3JdA1tioiISDWonAVIfEwk53dtxsc5+ZRXOL/jiIiISIhQOQugEekp7D5UTNYmDW2KiIhI1aicBdB5XZsRExWhBWlFRESkylTOAqh+bBTndE7m45wdVGhoU0RERKpA5SzAMtNT2H6giKV5+/2OIiIiIiFA5SzALujWnOhIY6aGNkVERKQKVM4CrGF8NEM7NmVG9nac09CmiIiInJjKWS3ITE8hd28hOdsO+h1FREREgpzKWS0Y1j2FyAhjRrYWpBUREZETUzmrBU3qxTC4fRNmrNihoU0RERE5IZWzWjIiPZWNuw+zNv+Q31FEREQkiKmc1ZLhPZpjhoY2RURE5IRUzmpJs8Q4BrTxhjZFREREvo/KWS3K7JnCmvwCNu7S0KaIiIgcn8pZLRqRngKgvTZFRETkewW0nJnZCDNbY2brzezu4xw/28wWm1mZmV1x1Pt9zGyemeWY2XIzGx/InLUltWE8fdIa6bkzERER+V4BK2dmFgk8DmQC3YGrzaz7MadtAW4EXj3m/SPA9c65HsAI4BEzaxSorLVpZM8UsrceJHfvEb+jiIiISBAK5J2zgcB659xG51wJ8Bow+ugTnHObnHPLgYpj3l/rnFtX+XobsBNIDmDWWpOZngpo1qaIiIgcXyDLWUsg96if8yrfqxYzGwjEABuOc2yimWWZWdauXbtOOWhtSmuSQI8WDfTcmYiIiBxXUE8IMLNU4GXgB865imOPO+eeds5lOOcykpND58bayJ6pLNmyn+0HCv2OIiIiIkEmkOVsK5B21M+tKt+rEjNrAHwE/Mo5N7+Gs/nqX7M2Z+rumYiIiBwjkOVsIdDJzNqZWQxwFfB+VS6sPP8d4CXn3JsBzOiLDsn16dI8UUObIiIi8h0BK2fOuTLgDuBjYBUwzTmXY2YPmNkoADMbYGZ5wJXAU2aWU3n5OOBs4EYzW1r5p0+gsvphRHoKCzftZVdBsd9RREREJIiYc87vDDUiIyPDZWVl+R2jylbvOMiIR77id5elc+3gNn7HERERkVpkZouccxnHOxbUEwLCWZfmibRvWk/PnYmIiMh/UDnziZkxIj2FeRv3sO9wid9xREREJEionPkoMz2V8grHJyvz/Y4iIiIiQULlzEfpLRvQqnG8dgsQERGRf1M585GZkZmewj/X7+ZAYanfcURERCQIqJz5bER6KqXljs9Wa2hTREREVM581zetESkN4pixQrM2RUREROXMdxER3qzNL9bu4nBxmd9xRERExGcqZ0EgMz2F4rIKPl+z0+8oIiIi4jOVsyCQ0bYJTevHaGhTREREVM6CQWSEcVGPFD5fs5Oi0nK/44iIiIiPVM6CxMj0VI6UlPPF2l1+RxEREREfqZwFiUHtm9AoIZoZK7QgrYiISF2mchYkoiMjGNatObNX7aS4TEObIiIidZXKWRAZ2TOVguIy5q7f43cUERER8YnKWRA5o2MSibFRTNfQpoiISJ2lchZEYqMiubB7cz5ZlU9peYXfcURERMQHKmdBZkR6CvuPlDJ/o4Y2RURE6iKVsyBzTudkEmIimZGtBWlFRETqIpWzIBMXHcl5XZsxK2cH5RXO7zgiIiJSy1TOglBmegq7D5WwcNNev6OIiIhILVM5C0LndWlGbFQEMzW0KSIiUueonAWherFRnNM5mZnZO6jQ0KaIiEidonIWpDJ7prDjYBFLcvf7HUVERERqkcpZkLqgW3OiI42Z2VqQVkREpC5ROQtSDeKiObNjU2Zk78A5DW2KiIjUFSpnQSwzPZW8fYVkbz3odxQRERGpJSpnQWxY9+ZERhgzNLQpIiJSZ6icBbHG9WIY0j5JQ5siIiJ1iMpZkBuRnsK3uw+zJr/A7ygiIiJSC1TOgtzwHimYwYwVWpBWRESkLlA5C3LJibEMaNtEz52JiIjUESpnIWBkegpr8w+xYdchv6OIiIhIgKmchYAR6akA2mtTRESkDlA5CwEpDePo27oR01doaFNERCTcqZyFiJHpqeRsO8iWPUf8jiIiIiIBpHIWIkakpwBoYoCIiEiYUzkLEWlNEkhv2YAZeu5MREQkrKmchZDM9FSW5u5n2/5Cv6OIiIhIgKichZDMyqFNzdoUEREJXypnIaR9cn26NE9UORMREQljKmchJrNnCgs372VnQZHfUURERCQAVM5CTGZ6Ks7Bxzn5fkcRERGRAFA5CzGdm9enfXI9ZmpJDRERkbCkchZizIzM9BTmb9zL3sMlfscRERGRGqZyFoIy01Mpr3B8slITA0RERMKNylkI6tGiAWlN4rUgrYiISBhSOQtB3tBmKl+v382BwlK/44iIiEgNUjkLUSPSUygtd8xepVmbIiIi4UTlLET1adWI1IZxGtoUEREJMypnISoiwhjeI4Uv1u7iUHGZ33FERESkhqichbCRPVMpKavg89U7/Y4iIiIiNUTlLIT1b9OYpvVjmaEFaUVERMKGylkIi4wwhvdozuerd1FYUu53HBEREakBKmchbmTPVApLy/li7S6/o4iIiEgNUDkLcYPaNaFxQrSGNkVERMKEylmIi4qMYFj35ny2aifFZRraFBERCXUqZ2Egs2cqBcVlfL1+t99RRERE5DSpnIWBoR2akhgXxfQVWpBWREQk1KmchYGYqAiGdWvOJyvzKS2v8DuOiIiInIaAljMzG2Fma8xsvZndfZzjZ5vZYjMrM7Mrjjl2g5mtq/xzQyBzhoMR6SkcKCxl3oY9fkcRERGR0xCwcmZmkcDjQCbQHbjazLofc9oW4Ebg1WOubQLcDwwCBgL3m1njQGUNB2d3TiYhJlJ7bYqIiIS4QN45Gwisd85tdM6VAK8Bo48+wTm3yTm3HDh2LG448Ilzbq9zbh/wCTAigFlDXlx0JOd3bcasnB2UVzi/44iIiMgpCmQ5awnkHvVzXuV7gb62zspMT2XP4RIWfLvX7ygiIiJyikJ6QoCZTTSzLDPL2rVLK+Sf2yWZ2KgIZmpBWhERkZAVyHK2FUg76udWle/V2LXOuaedcxnOuYzk5ORTDhou6sVGcW6XZGbm7KBCQ5siIiIhKZDlbCHQyczamVkMcBXwfhWv/Ri4yMwaV04EuKjyPTmJzPRU8g8WsyR3n99RRERE5BQErJw558qAO/BK1SpgmnMux8weMLNRAGY2wMzygCuBp8wsp/LavcCDeAVvIfBA5XtyEud3a0ZMZAQztCCtiIhISDLnwmP4KyMjw2VlZfkdIyjc9MJC1uwo4J+/OA8z8zuOiIiIHMPMFjnnMo53LKQnBMjxjUhPYev+QlZsPeB3FBEREakmlbMwdFH35kRFmBakFRERCUEqZ2GoUUIMQzokMWPFdsJl2FpERKSuUDkLUyPSU9i05wirdxT4HUVERESqQeUsTF3UPYUIQ0ObIiIiIUblLEwlJ8YyoG0TZqzQbgEiIiKhROUsjGWmp7Bu5yHW79TQpoiISKhQOQtjI9JTAbQgrYiISAhROQtjKQ3j6Ne6kZ47ExERCSEqZ2FuZM9UVm4/yOY9h/2OIiIiIlWgchbmhvdIATRrU0REJFSonIW5tCYJ9GzZUOVMREQkRKic1QGZPVNYlrufrfsL/Y4iIiIiJ6FyVgdkVs7anKm7ZyIiIkFP5awOaNe0Hl1TEpmZrQVpRUREgp3KWR2RmZ5K1uZ97DxY5HcUEREROQGVszois2cKzsHHORraFBERCWYqZ3VEp2b16ZBcT7M2RUREgpzKWR1hZmSmpzJ/4x72HCr2O46IiIh8D5WzOmREegoVDj5Zme93FBEREfkeKmd1SI8WDWjdJEFDmyIiIkFM5awO8YY2U/h6/W4OHCn1O46IiIgch8pZHTMiPYWyCsenqzS0KSIiEoxUzuqYPmmNaNEwjhlakFZERCQoqZzVMWbG8PQUvly3m/1HSvyOIyIiIsdQOauDRvVuQWl5BWf98XN++c4KluftxznndywREREBovwOILWvb+vGvHnbEF75ZgtvL87j1W+20DUlkfED0ri8b0saJcT4HVFERKTOsnC5Y5KRkeGysrL8jhFyDhaV8v7Sbby+MJcVWw8QExXB8B4pXDUgjSHtk4iIML8jioiIhB0zW+ScyzjuMZUz+ZeV2w4yLSuXd5Zs5UBhKWlN4rmyfxpXZrQitWG83/FERETChsqZVEtRaTkf5+zg9YW5zN2whwiDszsnc9WANM7v2pyYKD2qKCIicjpUzuSUbdlzhDcW5fJGVh47DhaRVC+Gsf1bMS4jjY7N6vsdT0REJCSpnMlpK69wfLl2F68t3MLsVTspq3D0b9OY8QPSuLhnKvViNbdERESkqlTOpEbtKijm7cV5vJ6Vy8Zdh6kXE8moPi0Yl5FGn7RGmGkSgYiIyImonElAOOfI2ryP1xfm8tHy7RSWltOleSLjKpfkaFJPS3KIiIgcj8qZBFxBUSkfLNvO61m5LMvdT0xkBMN6NGd8RhpndmyqJTlERESOonImtWr1joO8vtBbkmP/kVJaNornyoxWXJmRRstGWpJDRERE5Ux8UVxWzqycfKZl5fLVut2YwVmdkhmfkcaF3ZsRGxXpd0QRERFfqJyJ73L3HuGNRXm8kZXL9gNFNKkXw+V9WzJ+QBqdmyf6HU9ERKRWqZxJ0CivcHy1bhfTsnL5ZGU+peWOvq0bMT4jjUt6t6C+luQQEZE6QOVMgtKeQ8W8s2Qrry3MZf3OQyTERHJJr1TGD2hNv9ZakkNERMKXypkENecci7fsZ9rCXD5Yvo0jJeV0bFaf8RlpjOnXkqT6sX5HFBERqVEqZxIyDhWX8dHybby2MJclW/YTHWlc2K054wekcVanZCK1JIeIiIQBlTMJSWvzC/69JMfewyW0aBjHFf29JTnSmiT4HU9EROSUqZxJSCspq+DTVfm8tjCXr9btAmBoh6aMH5DGRT2aa0kOEREJOSpnEja27i/kjaxc3sjKY+v+QholRHNl/1bccX4nGsZH+x1PRESkSlTOJOxUVDi+3rCb1xbmMmPFdprUi+FXF3fjsj4tNctTRESC3onKWURthxGpCRERxlmdknl8Qj/ev+NMWjZO4L9fX8aEZ75h/c5DfscTERE5ZSpnEvLSWzbk7Uln8LvL0snZdoDM//2Sv3y8hqLScr+jiYiIVJvKWXXMug+WvQ6lhX4nkWNERhjXDm7D7DvP5dJeLXjs8/UM+9sXfL56p9/RREREqkXlrKpKjsCa6fDORPhrF5h+F+xY4XcqOUZyYiwPj+/D1FsGExsVyQ9eWMhtLy9i+wEVahERCQ2aEFAdzsGmf8Lil2Dle1BeDC36Qr/rIf0KiGsQ2O+Xaikpq+CZrzby6GfriDDjvy/szI1D2xIdqX+TiIiIvzRbMxAK98HyN2Dxi5CfDdEJ0ONyr6ilDQLNGAwauXuP8Jv3c5i9eiddUxL5/eXp9G/TxO9YIiJSh6mcBZJzsG2JV9JWvAklh6BpF6+k9b4K6jWt/UzyHc45Zq3M5zfv57D9QBHjM9K4O7MrjevF+B1NRETqIJWz2lJ8CFa+6w175n4DEdHQ9WKvqLU/DyI0nOa3w8Vl/O/sdTz7z29pEBfFPSO7cUW/VkRoz04REalFKmd+2LnaK2nLpkLhXmjYGvpeC32vgYat/E5X563ecZB738kma/M+BrRtzO8u60mXlES/Y4mISB2hcuansmJY/ZFX1DZ+DhYBHS/07qZ1HgGR2nLILxUVjjcX5fE/M1ZRUFTGzWe24ycXdiIhJsrvaCIiEuZUzoLFvk2w5BVYMgUKtkG9ZOgzAfpeD007+p2uztp7uIQ/zljN61m5tGgYx/2jenBR9+baBkpERAJG5SzYlJfBhtne3bQ1M8CVQ5szvbtp3UdBdLzfCeukrE17uffdbFbvKOCCrs34zagepDVJ8DuWiIiEIZWzYFaQD8te9Yra3o0Q2xB6jfOKWmovv9PVOaXlFbzw9Sb+9ulaKpzjv87vxC1ntScmSpM5RESk5qichYLjLXCb2scraT2v1AK3tWzb/kJ++0EOH+fk07FZfX53WTqD2yf5HUtERMLEicpZlW4HmNlPzKyBeZ41s8VmdlEVrhthZmvMbL2Z3X2c47Fm9nrl8W/MrG3l+9Fm9qKZrTCzVWZ2T1VyhjQzaHcWjH0Gfr4GMv8MFWXw0c+87aLevR22zPdKnARci0bxPHVdBs/dmEFRaTlXPT2fn01byu5DxX5HExGRMFelO2dmtsw519vMhgO3AvcBLzvn+p3gmkhgLTAMyAMWAlc751Yedc7tQC/n3G1mdhVwuXNuvJlNAEY5564yswRgJXCuc27T931fyN85Ox7nYNti727avxe47Vy5wO3VWuC2lhSWlPPY5+t4+suNJMRE8f9GdOHqAa21NpqIiJyy075zBvzr/4VG4pWynKPe+z4DgfXOuY3OuRLgNWD0MeeMBl6sfP0mcIF5U+QcUM/MooB4oAQ4WMWs4cMMWvaHS/8X7lwDox+H+MYw6174a1eYdj2snw0VFX4nDWvxMZHcNbwrM35yFt1SE/nVO9mMmTyX7K0H/I4mIiJhqKrlbJGZzcIrZx+bWSJwskbQEsg96ue8yveOe45zrgw4ACThFbXDwHZgC/AX59zeKmYNT7H1vUVsb54Ft38DAyfCt1/BlDHwv71hzh/hQJ7fKcNax2aJTL1lMA+P603u3iOMeuyf/PaDHAqKSv2OJiIiYaSq5exm4G5ggHPuCG51S9EAACAASURBVBAN/CBgqby7buVAC6AdcKeZtT/2JDObaGZZZpa1a9euAMYJMs26wog/wJ2r4YrnIakDzPkD/C0dplwBK9+HchWGQDAzxvRrxWd3nsvVA1vzwtxNXPjwF3y4fBvhMrlGRET8VdVyNgRY45zbb2bXAvfi3eU6ka1A2lE/t6p877jnVA5hNgT2ABOAmc65UufcTuBr4Dvjss65p51zGc65jOTk5Cr+KmEkKhbSx8D178JPlsHZd0F+Dky7Dh7uBp/8Gnav9ztlWGqYEM3vL+/JO7cPpWn9WO54dQk3PL+QTbsP+x1NRERCXFXL2WTgiJn1Bu4ENgAvneSahUAnM2tnZjHAVcD7x5zzPnBD5esrgM+cd/thC3A+gJnVAwYDq6uYtW5q3BbO/xX8dAVMmAZpg2DuY/BYf3h+JCx7DUqO+J0y7PRJa8R7PxrK/Zd2Z/HmfVz0yJf876frKC4r9zuaiIiEqKrO1lzsnOtnZr8Gtjrnnv3Xeye5biTwCBAJPOec+72ZPQBkOefeN7M44GWgL7AXuMo5t9HM6gPPA93xJh4875z784m+Kyxna56u4y5weyX0u0EL3AZA/sEiHvxwJR8u3067pvV4cHQ6Z3bSjFoREfmu016E1sy+AGYCNwFnATuBZc65njUZ9HSonJ3AcRe47Q19r4P0sZDQxO+EYeXLtbv49XvZbNpzhEt7t+C+i7vRrEGc37FERCSI1EQ5S8F7Dmyhc+4rM2uNt+7YyYY2a43KWRUV7oPlb3hFLX8FRMZA14uhz7XQ4TyIiPQ7YVgoKi1n8pwNTJ6zgdioCO68qDPXDWlLpNZGExERamj7JjNrDgyo/HFB5YP6QUPl7BRsXwZLXoEV07zSltgCel8Ffa6Bph39ThcWvt19mF+/l81X63aT3rIBv7+sJ73TGvkdS0REfFYTd87GAX8G5uA9A3YWcJdz7s0azHlaVM5OQ1kxrJkBS1+B9Z+Cq4C0wdBnAvS4XPt6nibnHB8u386DH65k16Firh3Uhp8P70LD+Gi/o4mIiE9qopwtA4b9626ZmSUDnzrnetdo0tOgclZDCnZ4MzuXvgK710J0AnQbBX2vgTZnQkRVJ/jKsQ4WlfLwrLW8NG8TTerFcu/F3RjdpwXephgiIlKX1EQ5W3H0w/9mFoEmBIQ35yAvC5ZOgey3ofggNGrj3U3rfTU0buN3wpCVvfUAv3o3m2W5+zmjQxIPjE6nY7P6fscSEZFaVBPl7M9AL2Bq5VvjgeXOuV/UWMrTpHIWQCVHYPWH3t20jV8ADtqd7U0i6HYpxCT4nTDklFc4pi7Ywp9mrqawtJxbz+7AHed3JC5aEzJEROqCmpoQMBYYWvnjV865d2ooX41QOasl+7f837Dnvk0Qkwjpl3tFLW2gt1m7VNmugmL+MH0V7yzZSlqTeB4a04uhHbU2mohIuKuRchbsVM5qWUUFbJnrzfZc+S6UHoGkTv837Nkg1e+EIWXuht3c+242m/cc4X/G9GRcRtrJLxIRkZB1yuXMzAqA451ggHPOBc00PpUzHxUXQM673t20LfPAIqDDBd4kgi4jvT1A5aQOFZcxacoivlq3mzuHdeaO8ztqsoCISJjSnTOpPXs2wNJXYdlUOLgV4hpBzyu9opbaR8OeJ1FSVsEv3lrOO0u2cs2g1jwwOl0L14qIhCGVM6l9FeWwcY53N23Vh96WUc16eCWt13iop+eqvo9zjj99vIbJczYwrHtzHr26ryYKiIiEGZUz8VfhPsh+y7ujtnURRERB5xHeTgSdhkGkFmM9nhfnbuI3H+TQr3Vj/nF9Bo3rxfgdSUREaojKmQSPnau8u2nLXofDO6Fesncnrc810Ly73+mCzvQV2/np60tJaxzPizcNpFVjLVsiIhIOVM4k+JSXeltFLZkCa2dCRRm06OuVtJ5XQHxjvxMGjW827uGHL2URHx3JCz8YSPcWQTMPR0RETpHKmQS3w7th+TTvjlp+NkTGQteLvefT2p8HEXreas2OAm58fgGHisp46rr+nKG10EREQprKmYQG52DHcm/ttBXTvGfVGrSE3ld5d9SSOvid0Ffb9hdy4/ML+Hb3Yf46rg+jerfwO5KIiJwilTMJPWXFsGaGdzdt/afgKiBtsHc3rcflEJvod0JfHCgs5ZaXsljw7V7uvbgbPzyrvd+RRETkFKicSWg7uB2Wv+bdUduzDqIToPto725am6EQEeF3wlpVVFrOz6YtZfqKHfzwzHb8cmQ3IrQWmohISFE5k/DgHORlwdIpkP02FB+ERm2g/40w5A6IqjtLTZRXOB78cCUvzN3Epb1b8JcrexEbpWfzRERChcqZhJ+SI7D6Q2+257dfQEpPGPssJHfxO1mtcc7x1JcbeWjGaoa0T+Kp6/vTIE5rxomIhIITlbO6NR4k4SMmAXqNgxveh6tehYPb4KmzYcEz3h22OsDMuO2cDjw8rjcLN+1l3JPzyD9Y5HcsERE5TSpnEvq6XgyT5kHbs2D6z+GVK6Ag3+9UtWZMv1Y8d+MAcvceYcwTc1m/s8DvSCIichpUziQ8JDaHa96AkX+BTf+EyUNg9Ud+p6o1Z3dO5vVbh1BcVsEVT85j0ea9fkcSEZFTpHIm4cMMBt4Ct34JDVvBaxPg/f+C4kN+J6sV6S0b8vakM2icEMOEZ75hVs4OvyOJiMgpUDmT8JPcBW7+FM78b1j8Mjx1ljfLsw5onZTAm7cNoWtqA26bsohXvtnsdyQREakmlTMJT1ExcOFv4MaPvH08n70I5vwRysv8ThZwSfVjmXrLIM7r0oxfvZPNX2etIVxmZYuI1AUqZxLe2g6F2/4J6WNhzh/g+UzYu9HvVAGXEBPFU9f1Z3xGGo9+tp5fvLWc0vIKv2OJiEgVqJxJ+ItvBGOf8dZB27UGnjzLWx8tzO8mRUVG8NDYnvzkgk5My8pj4ktZHCkJ/zuHIiKhTuVM6o6eV8Ckr6FFX3jvRzDtOjgS3rMazYz/HtaZP1zeky/W7uLqp+ez51Cx37FEROQEVM6kbmmUBte/B8MegDUz4YkhsH6236kCbsKg1jx1XQZr8gsYO3kum/cc9juSiIh8D5UzqXsiImHoT+CWz7whzyljYMbdUBreq+sP696cV344mAOFpYydPJcVeQf8jiQiIsehciZ1V2ovmDgHBt4K30yGp8+FHSt8DhVY/ds05s1JZxAbFcn4p+fxxdpdfkcSEZFjqJxJ3RYdDyP/BNe8BYV74ZnzYe6jUBG+Mxs7JNfnndvPoG1SPW5+YSFvLcrzO5KIiBxF5UwEoNOF3v6cnS6CWffCy6PhwFa/UwVMswZxvH7rYAa1b8KdbyzjiTnrtRaaiEiQUDkT+Zd6STB+Cox6FPIWeftzZr/td6qASYyL5vkbBzK6Twv+NHMN97+fQ3mFCpqIiN9UzkSOZgb9rofbvoKkTvDmD+DtW6EoPB+ej4mK4G/j+nDr2e15ad5mfvTKYopKy/2OJSJSp6mciRxPUge46WM49x5Y8QZMPhM2z/U7VUBERBj3jOzGry/pzscrd3D9sws4cKTU71giInWWypnI94mMgnPvhptmestvvHAxzH4Aykr8ThYQN53Zjkev7svS3P1c8eRctu0v9DuSiEidpHImcjJpA71hzj7XwFd/hWeHwa61fqcKiEt6teDFmway40ARY56Yy+odB/2OJCJS56iciVRFbCKMfsybMLB/Czx1Nix8Niz35xzSIYk3Jg3B4bjyyXnM37jH70giInWKyplIdXS7FCbNhTZD4KOfwavj4dBOv1PVuK4pDXj79qGkNIjj+mcX8NHy7X5HEhGpM1TORKqrQaq3aG3mn2DjHG9/zjUz/E5V41o2iueN24bQO60hd0xdzPNff+t3JBGROkHlTORURETAoFvh1i8gMRWmXgUf/BRKwmtD8UYJMbx88yCGd0/htx+s5H+mr6JCa6GJiASUypnI6WjWDW6ZDWf8GBa94D2LtnWx36lqVFx0JI9f04/rBrfhqS838rNpSykpC9/trURE/KZyJnK6omLhogfhhvehtNCbzfnln6EifBZzjYwwHhjdg7uGd+Hdpdu46YWFHCou8zuWiEhYUjkTqSntzoZJX0P30fDZ7+D5kbBvk9+paoyZ8aPzOvKXK3szf+Mexj81j50FRX7HEhEJOypnIjUpvjGMfRbGPAM7V3o7CyydGlZLblzRvxX/uCGDb3cfZswTc9m465DfkUREworKmUhNM4Ne47y7aKm94N3bvD06j+z1O1mNObdLM16bOJii0nLGTp7L4i37/I4kIhI2VM5EAqVRa7jhA7jgflj1AUwe6i29ESZ6tWrEW5POoEF8NBOemc/sVfl+RxIRCQsqZyKBFBEJZ/0MfjgbYuvDS6Ph419BaXg8q9UmqR5vTTqDzs0TueWlLF5bsMXvSCIiIU/lTKQ2tOgDE7+AAT+EeY/BM+dDfo7fqWpE0/qxTL1lMGd3Tubut1fwyKdrcWH0jJ2ISG1TOROpLTEJcPFfYcIbcHgnPH0ezHsCKkJ/zbB6sVE8c30GV/ZvxSOfruOX76ygrDz0fy8RET+onInUts4XwaR50OF8+PgemHI5HNzmd6rTFh0ZwZ+u6MV/nd+RqQtyuW3KIgpLwmetNxGR2qJyJuKH+slw9VS45BHIXQCTz4CV7/md6rSZGXde1IUHL0tn9uqdXPvsN+w/UuJ3LBGRkKJyJuIXM8j4Adz6FTRuB9Ouh7cnwuHdfic7bdcNbsPka/qxYusBrnhyHtv2F/odSUQkZKicifitaUe4eRac8wvIfhse7Q+LXgz5Z9FGpKfy0k0DyT9QxJgn5rI2v8DvSCIiIUHlTCQYREbDeb/0Fq5t3gM++DE8nwn5K/1OdloGt09i2m1DqHCOKybPJWtT+CzEKyISKCpnIsEkuQvc+BGMfgJ2r4WnzoJP7oeSI34nO2XdUhvw9u1n0DQxlmv+8Q2zcnb4HUlEJKipnIkEGzPoew3ckQW9roKvH4EnBsHaj/1OdspaNU7gzdvOoFtqA26bsoipWqxWROR7qZyJBKt6SXDZ43DjdIiKh1fHwevXheyyG03qxfDqLYM4u3My97y9gr/PXqfFakVEjiOg5czMRpjZGjNbb2Z3H+d4rJm9Xnn8GzNre9SxXmY2z8xyzGyFmcUFMqtI0Go7FG77J5x/H6ybBY8NgPmToSL01hBLiPEWqx3brxUPf7KW+97LprxCBU1E5GgBK2dmFgk8DmQC3YGrzaz7MafdDOxzznUE/gb8sfLaKGAKcJtzrgdwLlAaqKwiQS8qBs7+Odw+D9IGwcy74ZnzYOtiv5NVW3RkBH+5sheTzu3AlPlb+NEriykqDb2iKSISKIG8czYQWO+c2+icKwFeA0Yfc85o4MXK128CF5iZARcBy51zywCcc3ucc/rbW6RJe7j2LbjieSjY4e3ROf0uKDrgd7JqMTN+MaIrv76kOzNzdnD9cws4UKh/f4mIQGDLWUsg96if8yrfO+45zrky4ACQBHQGnJl9bGaLzez/BTCnSGgxg/QxcMdCGHgLLHgGHhsIOe9AiD3DddOZ7fj71X1ZsmUf45+aR/7BIr8jiYj4LlgnBEQBZwLXVP7v5WZ2wbEnmdlEM8sys6xdu3bVdkYRf8U1hJF/hltmQ/1m8MaN8MqVsPdbv5NVy6jeLXjhBwPJ21fImCfmsn7nIb8jiYj4KpDlbCuQdtTPrSrfO+45lc+ZNQT24N1l+9I5t9s5dwSYDvQ79gucc0875zKccxnJyckB+BVEQkDL/nDL5zDiIdgyD54YDF/9FcpCZ0/LoR2b8trEwRSXlXPlk3NZvGWf35FERHwTyHK2EOhkZu3MLAa4Cnj/mHPeB26ofH0F8Jnz5tZ/DPQ0s4TK0nYOENpLpYsEUmQUDJ4EP1oAnYbB7Ae8BWw3z/U7WZWlt2zIW5POoEF8NBOemc/nq3f6HUlExBcBK2eVz5DdgVe0VgHTnHM5ZvaAmY2qPO1ZIMnM1gM/A+6uvHYf8DBewVsKLHbOfRSorCJho2FLGD8Frn7d21Xg+Ux470dwJDS2TWqTVI+3Jp1Bp2aJ/PClLN7Iyj35RSIiYcbCZRHIjIwMl5WV5XcMkeBRchi++CPMe9x7Pu2i30Hvq70JBUHuUHEZk6Ys4qt1u/l/I7ow6ZwOWAjkFhGpKjNb5JzLON6xYJ0QICKnK6YeDHsAbv0SkjrCu5PghUtg11q/k51U/dgonr1hAKN6t+BPM9fw2w9WUqHFakWkjlA5Ewl3zXvAD2bCpf8L+dkw+Qz47HdQWuh3shOKiYrgkfF9uPnMdrwwdxM/fm0JxWVa7lBEwp/KmUhdEBEB/W/0NlNPHwtf/hmeGALrZ/ud7IQiIoz7LunOL0d25cPl27nphYUUFGmxWhEJbypnInVJ/WQY8xRc/z5ERMKUMfDmTVCQ73eyE5p4dgceHtebbzbu5aqn57OzQIvVikj4UjkTqYvanwOT5sK5v4RVH3qbqS94Jqg3Ux/TrxX/uCGDjbsOM3byXDbtPux3JBGRgFA5E6mromLh3F94m6m36APTfw7PDoPty/1O9r3O7dKMqRMHc7i4nLGT57I8b7/fkUREapzKmUhdl9QBrn8PxvwD9m+Bp8+Bmb+E4uDcRqlPWiPevG0I8TGRXPX0fL5cq63bRCS8qJyJiLf2Wa8rvc3U+90A8x+Hxwd6Q55BqH1yfd6edAZtkupx0wsLeXfJsTvDiYiELpUzEfk/8Y3h0kfg5k+8169fA1Ov9u6oBZlmDeJ4/dbBZLRtzE9fX8o/vtrodyQRkRqhciYi35U2ECbOgWEPwsY58Pgg+PrvUB5cy1g0iIvmxZsGMrJnCr/7aBV/mL5Ki9WKSMhTOROR44uMhqE/9jZTb38ufHIfPH0u5C7wOdh/io2K5NGr+3H9kDY8/eVG7nxjGaXlFX7HEhE5ZSpnInJijdLg6qkw/hUo3AfPXgQf/NR7HSQiI4zfjurBXcO78M6Srdz8YhaHi8v8jiUickpUzkSkarpd4t1FG/IjWPyStzba8mnggmMY0cz40Xkd+dPYXny9fjcTnpnPnkPFfscSEak2lTMRqbrY+jD8997zaI1aw9u3wMuXwZ4Nfif7t3ED0njq2v6s3lHAFU/OI3fvEb8jiYhUi8qZiFRfai9vRufFf4WtS7x9Ouc8BGXBcafqwu7NefWWQew9XMKYyXPJ2XbA70giIlWmciYipyYiEgb80FsbrdslMOd/YPIZsPELv5MB0L9NE96aNIToCGP8U/OZu2G335FERKpE5UxETk9ic7jiObj2bW9vzpdGwdsT4UCe38no2CyRt24/gxaN4rjxuYV8tHy735FERE5K5UxEakbHC7x9Os++C7Lfhkd6wRs/gLwsX2OlNoznjVvPoHdaQ+6YupgX527yNY+IyMmonIlIzYmOh/PvhR8vhiG3w/rZ8I8L4B8XQvZbvi1i2zAhmpdvHsSF3Zpz//s5/Pnj1bggmWUqInIsC5e/oDIyMlxWlr//QheRYxQXwNKp8M1k2LsRGrSEgbd4+3cmNKn1OGXlFdz3Xg5TF2xhXEYr/nB5T6Ii9W9UEal9ZrbIOZdx3GMqZyIScBUVsG4WzH8Cvv0CouKhz9UwaBIkd67VKM45/vbpOv4+ex0XdG3GYxP6ER8TWasZRERUzkQkeOTneCVt+RtQXgwdL4TBt0OH88Gs1mJMmb+Z+97Lpm9aI569YQCN68XU2neLiKiciUjwObQLFj0PC/8Bh/IhuSsMug16jYeYhFqJMDN7Oz9+bSlpjeN56eZBtGwUXyvfKyKiciYiwausGHLegXmPw47lEN8Y+v/AezatQYuAf/03G/fww5eySIiJ5KWbBtElJTHg3ykionImIsHPOdgyzxvyXP0RWAT0uNx7Lq1V/4B+9eodB7nhuQUUlpTzjxsGMLBd7U9WEJG6ReVMRELLvk3wzdPeBuslBZA2CAZPgq6XQmRUQL4yb98Rrn9uAXn7Cnn06r4M75ESkO8REQGVMxEJVUUHYemr8M2TsO9baNAKBk2Eftd7w581bO/hEm56YSHL8/bz4GXpXDOoTY1/h4gIqJyJSKirKIe1H3tDnpu+gugE6DPBm0DQtFONftWRkjJ+9MpiPl+zi59e2ImfXNAJq8VZpCJSN6iciUj42LEC5j8JK6ZBeQl0Gu4NebY/t8aW4igtr+Cet1fw5qI8Jgxqzf2Xdic2SmuhiUjNUTkTkfBzaCdkVS7FcXgnJHfzSlqvcd42UqfJOcefP17DE3M20DYpgftH9eC8Ls1qILiIiMqZiISzsmJv3875T3h31eKbQMZNMOCH0CD1tD/+i7W7+O37OWzcfZgLuzXn15d0p3VS7azDJiLhS+VMRMKfc7D5a5g/2VuKIyISeozxNmBv0fe0PrqkrILnvv6Wv89eR1mF47ZzOjDpnA7a9klETpnKmYjULXu/hQVPw+KXvaU4Wg/xhjy7XHxaS3HsOFDEH6av4v1l22jZKJ77LunG8B4pmjAgItWmciYidVPRQVgyxVuKY/9maNjaW4qj73UQ3+iUP3b+xj3c/14Oa/ILOKtTU+6/tAcdm9WvweAiEu5UzkSkbqsohzUzvCHPzf+E6HrQ9xpvKY6kDqf0kWXlFbw8fzMPf7KWwpJybj6zHf91QSfqxwZmkVwRCS8qZyIi/7J9mbcUR/abUF4KnYfD4Nuh3dmntBTH7kPF/GnmaqZl5dEsMZZfXdyNUb1baKhTRE5I5UxE5FgF+ZD1nLcUx5Hd0KyH91xazyshOq7aH7dkyz5+/V4OK7YeYGDbJvx2dA+6pTYIQHARCQcqZyIi36e0yLuLNn8y5GdDQtPKpThuhsTq7a9ZXuGYlpXLn2au5kBhKdcNbsPPhnWhYUJ0gMKLSKhSORMRORnnvK2h5k/2nk+LiIL0sTD4tmovxbH/SAl/nbWWV77ZTKOEGH4xogtX9k8jIkJDnSLiUTkTEamOPRu8pTiWTIGSQ5Da25vhmT4WEppU+WNyth3g/vdyyNq8j96tGvLA6HR6p536LFERCR8qZyIip6LoACx7zStpO5ZDZCx0vRj6Xuvt5Rlx8kVonXO8u3Qrf5i+mt2HihmfkcZdw7uQVD824PFFJHipnImInK7ty2HpK7D8dSjcBw1aQp8J3p8m7U96eUFRKX+fvY7nv95EQkwkPx/ehQkDWxMVGVEL4UUk2KiciYjUlLJiWDMdlrwCG2aDq4A2Z3p307qPgph6J7x8XX4Bv/kgh6/X76FrSiIPjE5nYLuqD5WKSHhQORMRCYSD22DZVG/Yc+9GiEmE9Muhz7WQNvB7101zzjEzewcPfriSbQeKuKxPC+4Z2Y3mDaq/hIeIhCaVMxGRQHIOtszz7qblvAOlhyGpk3c3rfdV37skx5GSMibP2cBTX2wkOtL4yYWduPGMdsREaahTJNypnImI1JbiAsh513s+bcs8sEjoNAz6XAOdR0BUzHcu2bT7MA9+uJLZq3fSIbkevxnVg7M6JfsQXkRqi8qZiIgfdq/3StqyqVCwHRKSoNdV3r6ezXt85/TZq/J54MOVbN5zhMz0FH51cTdaNU7wIbiIBJrKmYiIn8rLYMNnsHQKrJ4OFaXewrZ9roGeV0B843+fWlRazrP//JZHP1sHwO3ndmTi2e2Jiz75sh0iEjpUzkREgsXhPbDiDVjysrddVGQsdLv0/7d370F13vedx99f7ncQcAQICSNAF+uCJFuWLcnGji9j2Zbt1E0dO2nWTTNRu5vspt3ubpJOm2Yz2212ptOkM5vZreI49S1XN0m98q2OkwpZN+tmo7uM0AUQiJsQAgTnwPntH8+RhKgsSzbwPHA+rxnmnPM8D+d8j58x/vh39VrTZt8FCd54s+bu8/zPVw7yyt4WyvIz+MbaBdxz43RtqC4yRSiciYgEjXPQ8l5s7bSfwUA35M6CJU/G1k6bDcDm+g7+6uX91Lf18ol5Ib7x8EJmF159uQ4RCT6FMxGRIIsMxNZOe8Hr/sRB+R3ebM8bHyGSmMazW47z3V+/T3goyhdrZvOlT1SRkZLkd+Ui8hEpnImITBZnm2Jrp70IZ47F1k57DJZ9jracRXz7jcP8YnczJblp/MVDC3hwcbG6OkUmIYUzEZHJxjk4scVrTTvwK4j0Q+E8WPZZ3p22hj9/s40DLT2sqizgvz+ykDlF2X5XLCLXQeFMRGQyGzznLW675wVo3A6WiJtzHxsz1/Bne4o4G4anVpXzlXvnkJOW7He1InINFM5ERKaK9iOX1k7rPU00I8TmjLv5H6duojOjiq8/MJ/fWVZKQoK6OkWCTOFMRGSqGR7yNl7f8zwcfg2iQxxJmsuz52/n5IwH+Oonb2VRaa7fVYrIB1A4ExGZyvo6oO5nuD3PY20HGCCF14eX0zX3cR577EnyMrWhukjQKJyJiMQD56DlXQZ3PEe07uekD5/jFCE6qn6XhQ/+exLzy/2uUERiFM5EROJNZIDm7T+no/YZFg/uIcEcvdNvJqtqFZQuh5m3QG6p31WKxC2FMxGROOWc461tuzj66++zIrKTRQknSCbincwugdKbYeZyL7DNWAapWf4WLBInrhbOxnV5aTNbA/w9kAg87Zz79qjzqcBzwM1AJ/Bp59zxEefLgAPAN51zfzuetYqITEVmxr0rl7PypqX8ZEcjf7rpCLk9h7g3p5GHs09RdvoACYc2xC5OgNCNMPPmS61roXmQoE3XRSbSuLWcmVkicAS4D2gCdgBPOucOjLjmPwDVzrk/NrMngN9xzn16xPmXAAds/7BwppYzEZEPFxmO8ureFtbXNrD/VA+FWan88Yo8npjRRlb7e9C0A5p3eXt9AqRkeS1qF1rXZi6H7GJ/v4TIFOBLt6aZrcRr8bo/9vrrAM65vxlxzRuxa7aaWRLQCoScc87MPgmsBvqAXoUz60ycGQAAFaVJREFUEZGx45xjy9FO1tc2sPFIOxkpiTy+fBZfuH02s6alQ+dRaN4JTTu9x9a9EB3yfjln5ojWteVQshRSMvz9QiKTjF/dmqVA44jXTcCtH3SNc27IzM4CBWY2AHwVr9Xtv4xjjSIiccnMWF1VyOqqQg619rC+toEXtp3gua3HeXBxCX9UU8niJU/Akie8X4gMQGud17J2IbAd+OfYmyVC0cLLW9cK5kBCgm/fT2QyG9cxZx/DN4HvOOd6r7ahr5mtA9YBlJWVTUxlIiJTzPziHP7u8aX81/vn8Y+bj/Oj7SfZUNfCyooC1tVUcNe8EJacBrNWeD8X9LZ5XaAXwtrel2DnM9651FwoXXYprJUuh6yQP19QZJIJZLcmUAvMil2WB0SBbzjn/vcHfZ66NUVExkbPQISfvHOSZ94+TmvPAHOLsvjiHRU8urSUlKSrtIZFo9D5/uWta6cPgBv2zufdcHnrWnE1JGuBXIlPfo05S8KbEHAP0Iw3IeAzzrn9I675ErB4xISAx5xzj496n2+iMWciIhMuPBRlQ90p1tc2cKj1HEU5qfzBqtl85tYyctOvcYP1cB+0vHcprDXtgp4m71xCMhQvurx1raASrtJjIjJV+LbOmZk9CHwXbymNZ5xzf21m3wJ2OudeNrM04HlgGdAFPOGcaxj1Ht9E4UxExDfOOTa938H62gberu8gMyWRJ1aU8Ye3z6Y0L/3637CnZcRkg13QvBsifd659Gne2msXA9vNkJE/tl9IJAC0CK2IiIyJfc1neXpTA/+vrgWAh6tL+GJNBQtnfIxN1qPD0H5oROvaTmg7iLeSEpBfcSmszVwORYshKeXjfxkRHymciYjImGruPs8P3z7Gj985SV94mNurCllXU8Edcwq52kSuazZ4Dk7tudS61rQTelu9c4kpMK0csoogM+Q9ZoUgc/rlzzNDCnESWApnIiIyLs6ej/Cj7Sf54eZjtJ0bZH5xNutqKnh4yQySE8dwKQ3noKf5Uuta90lvtmhvG/S1w2DPlX8vfVostF34uRDoRj3PDEHiNY6jExkDCmciIjKuBoeGefndU3x/UwNHTvdSkpvG51eX8+SKMrLTJiD0RM6PCGttV3neDuFzV36P9PxLIW50K9zoFrnEoK5EJZOFwpmIiEwI5xz/erid9bUNbG3oJDs1ic/cWsYfrC6nJPcjTB4YD+H+DwlwI1rkwr1XeAPzJimMbJG7rHVuxOuMQgU5uSKFMxERmXB1Td2sr23g1b0tJJjxyNIZrKupYH5xjt+lXbtw3zW2yLVBpP8Kb2CQUXDlEJc5HbKLoHgJZBZM+FcTfymciYiIbxq7+vnB28f46Y5GzkeGuXNuiHU1FayqLBibyQNBMdh79Va43tOXXg+dv/x3C+dB2W1QttJ7nFau9d6mOIUzERHxXXd/mBe3n+SHm4/T0TvIwhk5rKup4MHFJWM7eSDonPO6S3vbvEkOzbvgxFZo3AYDZ71rsksuD2tFiyAh0d+6ZUwpnImISGAMRIb51Z5m1m9qoKG9j9K8dP7w9tl8+pZZZKXG8fisaNRb7+3k1tjPNjjb6J1Lyfb2Nb0Q1kpvhpQMf+uVj0XhTEREAicadfzmUBvraxt453gXOWlJfPa2G/j8qnKm52jPTQC6G6FxO5zY4oW1tgOA87a+mrH0UuvarNs0bm2SUTgTEZFA23PyDN/f1MDr+1pJSkjg0djkgTlF2X6XFiznz0DjO5da1pp3wXDYO6dxa5OKwpmIiEwKJzr7eHrTMX6+q5GBSJS750/ni3dUcFtF/tSaPDBWIgPeTgoXwtoHjltbCUULNW4tQBTORERkUunqC/P81hM8t/U4nX1hqmfmsq6mgjULi0mKp8kD1ysahfaDl8Laia3Q0+SdGzlu7YaV3ri15ICsPReHFM5ERGRSGogM80+7m3h60zGOdfQxKz+dL6yeze8tn0VmPE8euB7djV5QuxDYrjhubRXMulXj1iaQwpmIiExqw1HHmwdOs772KLtPdpOWnMDd86fz0OIZfGJ+iIwUBbVrNnLc2omtcGr3lcet3bAS8m7QuLVxonAmIiJTxu6TZ/jVnmZe3dtKR+8g6cmJ3HPjdNZWl3DXvOmkJWtc1XW5bNzaVji5HQY1bm28KZyJiMiUMxx1bD/WySt1Lby2r5WuvjCZKYncu6CItdUzqJlbSGqSgsR1Gzlu7UQssPU0e+c0bm3MKJyJiMiUNjQcZVtDF6/sPcVr+1rp7o+QnZrEfQuKWLukhNurQqQkaSLBR3Zx3NrI9da4fNxa6c2QPg1SsyE1B1KyvOcpmeoavQKFMxERiRuR4Shbjnay4b1TvLG/lZ6BIXLSkrh/YTEPVZewuqowvraLGg/9XdC049LiuCPHrY1mCZeCWmr2iOdZXoi77Nion9HHk9KmTNBTOBMRkbgUHorydn07G+paeHP/ac4NDpGXkcyaWFBbWVGgpTnGQmQAOo7AYI+3AfzgOe95+MLzKx0bcTx8Dlz0wz8nISkW2HJGBLyRQS7nA46NvDbWqpeUMv7/XK5C4UxEROLeQGSYTe938ErdKd48cJq+8DD5mSmsWVTM2sUl3FpRQGLC1GiVmXScg0j/iMDWEwttI4PcuWs7Fu69ts9MTB0V5Ea00E0rh3v+cly/8tXCmeYei4hIXEhLTuS+BUXct6CIgcgw/3q4nQ11p/jl7mZ+tP0khVmpPLComLXVJSwvz1dQm0hm3ti0lEz4uDt2RaNeQLtqiBvZwjfieO9p6Kz3Hn2kljMREYlr58PD/PZwGxvqTvGbQ20MRKJMz07lwcUlrK0u4aayaSQoqMkYU7emiIjINegbHOKtQ228UneK3x5uJzwUpSQ3jQcXl/BQdQnLZuVpj08ZEwpnIiIi1+ncQIS3Draxoa6F2iPthIejlOal81C116K2uDRXQU0+MoUzERGRj6FnIMKb+0/zyt4WNr3fTmTYMSs/nYcWz2BtdQkLZ+QoqMl1UTgTEREZI2f7I7xxoJUNdS1sru9gOOooL8hgbfUMHqouYX5xtoKafCiFMxERkXHQ1Rfmjf2tvFLXwpajHUQdVIYyeajaa1GbW/Rxpx7KVKVwJiIiMs46egd5fZ8X1LYd68Q5mFuU5XV9LimhMpTld4kSIApnIiIiE6jt3ACv7/O6Pncc78I5mF+czdrqEtZWz6C8MNPvEsVnCmciIiI+aT07wGv7WthQ18KuE2cAWDgjxxujtriEsoIMnysUPyiciYiIBMCp7vO8utcLau82dgMwZ3oWd84NUTM3xIrZ+aQlJ/pcpUwEhTMREZGAaezq5/V9rWw80s47x7sID0VJTUrg1ooC7pwb4s65hVSGsjTzc4pSOBMREQmw8+Fhth3rpPZIOxuPtNPQ3gfAjNw0amKtaqurCslNT/a5UhkrCmciIiKTSNOZfmqPdFB7pJ3N9R2cGxwiMcFYOiuPmjkhauYWUj0zT5uzT2IKZyIiIpPU0HCUdxu72Xikndoj7dQ1n8U5yMtI5vaqQmrmhrhzboiinDS/S5XroHAmIiIyRXT1hXm7voONh9upfb+d9nODAMwryubOeSFq5oRYXj5NEwsCTuFMRERkCnLOcaj1HLVHvKC249gZwsNR0pITuK2igJo5Ie6cF6KiMFMTCwJG4UxERCQO9IeH2NbQeXG8WkOHN7GgNC891v1ZyKqqQnLSNLHAbwpnIiIicaixq//iWLUtRzvpjU0suKnswsSCEItLc0nQxIIJp3AmIiIS5yLDUfac7L64XMfe5rMATMtI5o5YUKuZU8h0TSyYEApnIiIicpnO3kFvYsGRdmqPdNDR600smF+cHVsEN8TN5dNITdLEgvGgcCYiIiIfKBp1HGztuThWbeeJLiLDjvTkRFZWFlAzp5A7502nvCBDEwvGiMKZiIiIXLO+QW9iwYXxasc7+wGYlZ9+cazaqsoCsjWx4CNTOBMREZGP7GRnPxvfb2fj4Xa2Hu2gLzxMUoJx0w3TvE3b54RYOCNHEwuug8KZiIiIjInwUJTdJ89cXFttX3MPAPmZKaysLGB1ZSGrqwooy1cX6NUonImIiMi4aD83yNv17Ww60sGWo5209gwA3tpqqyoLWF1VyKrKAs0CHUXhTERERMadc46Gjj62HO1kS30HWxs66e6PAFA1PYvVlQWsrCxkZUUBuRnxPV5N4UxEREQmXDTqONDSw5ajHWyu7+SdY12cjwyTYLCoNPdiN+gt5fmkp8TXkh0KZyIiIuK78FCU95q62VzfwZb6TvY0niEy7EhONJaVTbs4Xm3JrDySExP8LndcKZyJiIhI4PSHh9hx/Axb6jvYfLSD/ad6cA4yUhJZMTuf1ZWFrKoq4MbiqTcT9GrhLGmiixEREREByEhJurgbAUB3f5htDZ1sru9ky9EO/vrwQcDbYmplZQGrKr3JBbMLM6f0TFCFMxEREQmEvIwU1iwqYc2iEgBazw6w5WjHxQkGr+5tBaAkN+1iUFtdVUhx7tSaCapuTREREQk85xzHO/u9sBZrWTsTmwlaEcr0glplISsrC8jLSPG52g+nMWciIiIypUSjjkOt52IzQTt451gXfeFhzGBBSc7F9dVuKc8nMzV4HYUKZyIiIjKlRYaj1DV1s7m+k831Hew52U14OEpSgrGsLO9iN+iysmmkJPk/E1ThTEREROLK+fAwO090sbm+k61HO9jbfJaog/TkRG6ZnX+xG3TBjBwSfZgJqtmaIiIiElfSUxK5Y06IO+Z4M0HP9kfYdqyTrUe9lrVvv3YIgNz0ZG6ryI91gxZSGfJ/JqjCmYiIiEx5uRnJ3L+wmPsXFgPQ1jPA1gYvqG2u7+SN/acBKMpJ5e750/mbx6p9q1XhTEREROLO9Jw0Hl1ayqNLS3HO0dh1ns2xyQU9A0O+1qZwJiIiInHNzCgryKCsoIwnV5T5XQ7+T1cQERERkYvGNZyZ2RozO2xm9Wb2tSucTzWzn8bObzez8tjx+8xsl5ntjT3ePZ51ioiIiATFuIUzM0sEvgc8ACwAnjSzBaMu+wJwxjlXBXwH+F+x4x3Aw865xcBTwPPjVaeIiIhIkIxny9kKoN451+CcCwM/AR4ddc2jwLOx5y8B95iZOef2OOdOxY7vB9LNLHUcaxUREREJhPEMZ6VA44jXTbFjV7zGOTcEnAUKRl3zu8Bu59zg6A8ws3VmttPMdra3t49Z4SIiIiJ+CfSEADNbiNfV+UdXOu+cW++cW+6cWx4KhSa2OBEREZFxMJ7hrBmYNeL1zNixK15jZklALtAZez0T+CXw75xzR8exThEREZHAGM9wtgOYY2azzSwFeAJ4edQ1L+MN+Af4FPAb55wzszzgFeBrzrnN41ijiIiISKCMWziLjSH7MvAGcBD4mXNuv5l9y8weiV32A6DAzOqB/wxcWG7jy0AV8A0zezf2M328ahUREREJCnPO+V3DmFi+fLnbuXOn32WIiIiIfCgz2+WcW36lc4GeECAiIiISbxTORERERAJE4UxEREQkQBTORERERAJE4UxEREQkQBTORERERAJE4UxEREQkQBTORERERAJkyixCa2btwIkJ+KhCoGMCPkeune5JMOm+BI/uSTDpvgTPRNyTG5xzoSudmDLhbKKY2c4PWtFX/KF7Eky6L8GjexJMui/B4/c9UbemiIiISIAonImIiIgEiMLZ9VvvdwHyb+ieBJPuS/DongST7kvw+HpPNOZMREREJEDUciYiIiISIApn18jM1pjZYTOrN7Ov+V2PgJnNMrPfmtkBM9tvZl/xuybxmFmime0xsw1+1yIeM8szs5fM7JCZHTSzlX7XFO/M7E9jf7v2mdmPzSzN75rikZk9Y2ZtZrZvxLF8M3vTzN6PPU6byJoUzq6BmSUC3wMeABYAT5rZAn+rEmAI+DPn3ALgNuBLui+B8RXgoN9FyGX+HnjdOTcfWILuj6/MrBT4T8By59wiIBF4wt+q4tY/AmtGHfsa8JZzbg7wVuz1hFE4uzYrgHrnXINzLgz8BHjU55rinnOuxTm3O/b8HN5/bEr9rUrMbCbwEPC037WIx8xygRrgBwDOubBzrtvfqgRIAtLNLAnIAE75XE9ccs7VAl2jDj8KPBt7/izwyYmsSeHs2pQCjSNeN6EQEChmVg4sA7b7W4kA3wX+GxD1uxC5aDbQDvww1t38tJll+l1UPHPONQN/C5wEWoCzzrl/8bcqGaHIOdcSe94KFE3khyucyaRnZlnAPwF/4pzr8bueeGZma4E259wuv2uRyyQBNwH/xzm3DOhjgrtp5HKxMUyP4gXnGUCmmf2+v1XJlThvWYsJXdpC4ezaNAOzRryeGTsmPjOzZLxg9qJz7hd+1yOsBh4xs+N43f93m9kL/pYkeK39Tc65Cy3LL+GFNfHPvcAx51y7cy4C/AJY5XNNcslpMysBiD22TeSHK5xdmx3AHDObbWYpeIM2X/a5prhnZoY3huagc+7v/K5HwDn3defcTOdcOd6/J79xzqk1wGfOuVag0czmxQ7dAxzwsSTxujNvM7OM2N+ye9AkjSB5GXgq9vwp4J8n8sOTJvLDJivn3JCZfRl4A29GzTPOuf0+lyVeK83ngL1m9m7s2J875171sSaRoPqPwIux/8FsAD7vcz1xzTm33cxeAnbjzTzfg3YK8IWZ/Ri4Cyg0sybgr4BvAz8zsy8AJ4DHJ7Qm7RAgIiIiEhzq1hQREREJEIUzERERkQBROBMREREJEIUzERERkQBROBMREREJEIUzEZGPyczuMrMNftchIlODwpmIiIhIgCiciUjcMLPfN7N3zOxdM/sHM0s0s14z+46Z7Tezt8wsFLt2qZltM7M6M/tlbC9EzKzKzH5tZu+Z2W4zq4y9fZaZvWRmh8zsxdiq7yIi103hTETigpndCHwaWO2cWwoMA58FMoGdzrmFwEa81cEBngO+6pyrBvaOOP4i8D3n3BK8vRBbYseXAX8CLAAq8HawEBG5btq+SUTixT3AzcCOWKNWOt5mxlHgp7FrXgB+YWa5QJ5zbmPs+LPAz80sGyh1zv0SwDk3ABB7v3ecc02x1+8C5cDb4/+1RGSqUTgTkXhhwLPOua9fdtDsL0dd91H3tBsc8XwY/X0VkY9I3ZoiEi/eAj5lZtMBzCzfzG7A+zv4qdg1nwHeds6dBc6Y2R2x458DNjrnzgFNZvbJ2HukmlnGhH4LEZny9H92IhIXnHMHzOwvgH8xswQgAnwJ6ANWxM614Y1LA3gK+L+x8NUAfD52/HPAP5jZt2Lv8XsT+DVEJA6Ycx+1BV9EZPIzs17nXJbfdYiIXKBuTREREZEAUcuZiIiISICo5UxEREQkQBTORERERAJE4UxEREQkQBTORERERAJE4UxEREQkQBTORERERALk/wP8gYNVChkR9QAAAABJRU5ErkJggg==)

The plot above illustrates that after 6 epochs, the model begins to overfit to the training data.
"""

# Instantiate a Model class and train the model
model = Model(inputs=main_input, outputs=output_array)

model.compile(optimizer='adam',
              loss=loss_array,
              metrics = metrics_array)

history=model.fit(X_train, y_train_output,
          epochs=6, batch_size=512, class_weight=classes_weights, verbose=1, validation_split=0.2, callbacks=[early_stopping])

"""FINAL EVALUATION

Since the dataset is quite imbalanced, the F1 score is used to evaluate the model performance, since this metric takes into account both precision and recall.
"""

y_pred_test = model.predict(X_test)

THRESHOLD=0.5  #threshold between classes
f1_score_results = []
# Binary Outputs
for col_idx, col in enumerate(train_labels_names):    
    # Transform array of probabilities to class: 0 or 1
    y_pred_test[col_idx][y_pred_test[col_idx]>=THRESHOLD] = 1
    y_pred_test[col_idx][y_pred_test[col_idx]<THRESHOLD] = 0

for col_idx, col in enumerate(train_labels_names):
    print(f'{col} accuracy \n')
    f1_score_results.append(f1_score(y_test[col], y_pred_test[col_idx], average='macro'))
    print(classification_report(y_test[col], y_pred_test[col_idx]))

test_predictions = y_pred_test

#For evaluation
arr0=test_predictions[0]
arr1=test_predictions[1]
arr2=test_predictions[2]
arr3=test_predictions[3]
arr4=test_predictions[4]
arr5=test_predictions[5]
arr6=test_predictions[6]
arr7=test_predictions[7]
arr8=test_predictions[8]

column_values=['Defence','Education','Energy','General',
                                                  'Health',
                                                  'Infrastructure',
                                                  'Professional',
                                                  'Technology',
                                                  'Transport']

# Dataframe created to extract the "multilabel_confusion_matrix" and the "classification_report"
df = pd.DataFrame(np.hstack((arr0,arr1, arr2, arr3,arr4,arr5,arr6,arr7,arr8)),columns=column_values)

# Multilabel confusion matrix
multilabel_confusion_matrix(df, y_test)

# Classification report
print(classification_report(df, y_test))

"""PREDICTIONS"""

lstm_predictions_kaggle=model.predict(real_test_features)

Arr0=lstm_predictions_kaggle[0].round(0)
Arr1=lstm_predictions_kaggle[1].round(0)
Arr2=lstm_predictions_kaggle[2].round(0)
Arr3=lstm_predictions_kaggle[3].round(0)
Arr4=lstm_predictions_kaggle[4].round(0)
Arr5=lstm_predictions_kaggle[5].round(0)
Arr6=lstm_predictions_kaggle[6].round(0)
Arr7=lstm_predictions_kaggle[7].round(0)
Arr8=lstm_predictions_kaggle[8].round(0)

"""Add the predictions to one DataFrame called "df_strings""""

df_strings = pd.DataFrame(np.hstack((Arr0,Arr1, Arr2, Arr3,Arr4,Arr5,Arr6,Arr7,Arr8)),columns=column_values)

"""Convert the predictions of each class to strings"""

df_strings['Defence']=df_strings['Defence'].astype(int)
df_strings['Education']=df_strings['Education'].astype(int)
df_strings['Energy']=df_strings['Energy'].astype(int)
df_strings['General']=df_strings['General'].astype(int)
df_strings['Health']=df_strings['Health'].astype(int)
df_strings['Infrastructure']=df_strings['Infrastructure'].astype(int)
df_strings['Professional']=df_strings['Professional'].astype(int)
df_strings['Technology']=df_strings['Technology'].astype(int)
df_strings['Transport']=df_strings['Transport'].astype(int)

df_strings['Defence']=df_strings['Defence'].astype(str)
df_strings['Education']=df_strings['Education'].astype(str)
df_strings['Energy']=df_strings['Energy'].astype(str)
df_strings['General']=df_strings['General'].astype(str)
df_strings['Health']=df_strings['Health'].astype(str)
df_strings['Infrastructure']=df_strings['Infrastructure'].astype(str)
df_strings['Professional']=df_strings['Professional'].astype(str)
df_strings['Technology']=df_strings['Technology'].astype(str)
df_strings['Transport']=df_strings['Transport'].astype(str)

"""Create a column called "label" to enter the 0s or 1s of each class together in one column



"""

df_strings['label']=df_strings[['Defence','Education','Energy','General','Health','Infrastructure','Professional','Technology','Transport']].agg(''.join,axis=1)

df_strings = df_strings.drop(['Defence','Education','Energy','General','Health','Infrastructure','Professional','Technology','Transport'], axis=1)

real_test_docid=real_test_docid.to_frame()

"""Merge together in a DataFrame called "output" the "docid" column extracted before from the test dataset and the "label" column"""

output=pd.merge(real_test_docid, df_strings, left_index=True, right_index=True)

"""Export the final DataFrame called "output" which contains the columns "docid" and "label" with the same format as requested by kaggle"""

#output.to_csv('lstm.csv', index = False)
#files.download("lstm.csv")

"""## GRU Network"""

# Same architecture as LSTM
# In our case the input sequences are words and we have approximately 6000 words per instance. However, a reasonable limit of 250-600 max sequence length is often used in practice with large LSTM models.
MAXLEN = 500 

# For building this model we'll use the Keras functional API and not the common used Sequential() model. This is because with this API it's possible to build more complex models, such as multi-output and multi-inputs problems.
# We will be training our own embeddings using Keras Embedding Layer.
main_input = Input(shape=(MAXLEN,), dtype='int32', name='main_input')
x = Embedding(vocabulary_size, 100, input_length=MAXLEN)(main_input)
x = Dropout(0.3)(x)
x = Conv1D(64, 5, activation='relu')(x) #A Convolutional layer was added before the LSTM in order to speed-up the training time.
x = MaxPooling1D(pool_size=4)(x)
x = GRU(100)(x)
x = Dropout(0.3)(x)

# A Dense layer is created for each of ouput. The corresponding metrics and losses for each output will also be stored into dictionaries.
output_array = []
metrics_array = {}
loss_array = {}
# The code below iterates through each of the output binary columns and creates a dense layer.
for i, dense_layer in enumerate(train_labels_names):
    name = f'binary_output_{i}'
    binary_output = Dense(1, activation='sigmoid', name=name)(x)
    output_array.append(binary_output)
    metrics_array[name] = 'binary_accuracy'
    loss_array[name] = 'binary_crossentropy'

y_train_output = []
for col in train_labels_names:
    y_train_output.append(y_train[col])

# For each output we define the weight for each class in a dictionary format (class 5 is different from the rest)
weight_binary = {0: 0.5, 1: 10} # these values are obtained through calculations
weight_binary5={0:1,1:0.8} # these values are obtained through calculations
classes_weights = {}
classes_weights[0]=weight_binary
classes_weights[1]=weight_binary
classes_weights[2]=weight_binary
classes_weights[3]=weight_binary
classes_weights[4]=weight_binary
classes_weights[5]=weight_binary5
classes_weights[6]=weight_binary
classes_weights[7]=weight_binary
classes_weights[8]=weight_binary

# Implement early stopping to help limit overfitting
early_stopping = tf.keras.callbacks.EarlyStopping(
    monitor='val_loss', 
    verbose=1,
    patience=10,
    mode='max',
    restore_best_weights=True)

# Instantiate a Model class and train the model
model = Model(inputs=main_input, outputs=output_array)

model.compile(optimizer='adam',
              loss=loss_array,
              metrics = metrics_array)

history=model.fit(X_train, y_train_output,
          epochs=6, batch_size=512, class_weight=classes_weights, verbose=1, validation_split=0.2, callbacks=[early_stopping])

"""FINAL EVALUATION

Since the dataset is quite imbalanced, the F1 score is used to evaluate the model performance, since this metric takes into account both precision and recall.
"""

y_pred_test = model.predict(X_test)

THRESHOLD=0.5  #threshold between classes
f1_score_results = []
# Binary Outputs
for col_idx, col in enumerate(train_labels_names):    
    # Transform array of probabilities to class: 0 or 1
    y_pred_test[col_idx][y_pred_test[col_idx]>=THRESHOLD] = 1
    y_pred_test[col_idx][y_pred_test[col_idx]<THRESHOLD] = 0

for col_idx, col in enumerate(train_labels_names):
    print(f'{col} accuracy \n')
    f1_score_results.append(f1_score(y_test[col], y_pred_test[col_idx], average='macro'))
    print(classification_report(y_test[col], y_pred_test[col_idx]))

test_predictions = y_pred_test

#For evaluation
arr0=test_predictions[0]
arr1=test_predictions[1]
arr2=test_predictions[2]
arr3=test_predictions[3]
arr4=test_predictions[4]
arr5=test_predictions[5]
arr6=test_predictions[6]
arr7=test_predictions[7]
arr8=test_predictions[8]

column_values=['Defence','Education','Energy','General',
                                                  'Health',
                                                  'Infrastructure',
                                                  'Professional',
                                                  'Technology',
                                                  'Transport']

# Dataframe created to extract the "multilabel_confusion_matrix" and the "classification_report"
df = pd.DataFrame(np.hstack((arr0,arr1, arr2, arr3,arr4,arr5,arr6,arr7,arr8)),columns=column_values)

# Multilabel confusion matrix
multilabel_confusion_matrix(df, y_test)

# Classification report
print(classification_report(df, y_test))

"""PREDICTIONS"""

gru_predictions_kaggle=model.predict(real_test_features)

Arr0=gru_predictions_kaggle[0].round(0)
Arr1=gru_predictions_kaggle[1].round(0)
Arr2=gru_predictions_kaggle[2].round(0)
Arr3=gru_predictions_kaggle[3].round(0)
Arr4=gru_predictions_kaggle[4].round(0)
Arr5=gru_predictions_kaggle[5].round(0)
Arr6=gru_predictions_kaggle[6].round(0)
Arr7=gru_predictions_kaggle[7].round(0)
Arr8=gru_predictions_kaggle[8].round(0)

"""Add the predictions to one DataFrame called "df_strings""""

df_strings = pd.DataFrame(np.hstack((Arr0,Arr1, Arr2, Arr3,Arr4,Arr5,Arr6,Arr7,Arr8)),columns=column_values)

"""Convert the predictions of each class to strings"""

df_strings['Defence']=df_strings['Defence'].astype(int)
df_strings['Education']=df_strings['Education'].astype(int)
df_strings['Energy']=df_strings['Energy'].astype(int)
df_strings['General']=df_strings['General'].astype(int)
df_strings['Health']=df_strings['Health'].astype(int)
df_strings['Infrastructure']=df_strings['Infrastructure'].astype(int)
df_strings['Professional']=df_strings['Professional'].astype(int)
df_strings['Technology']=df_strings['Technology'].astype(int)
df_strings['Transport']=df_strings['Transport'].astype(int)

df_strings['Defence']=df_strings['Defence'].astype(str)
df_strings['Education']=df_strings['Education'].astype(str)
df_strings['Energy']=df_strings['Energy'].astype(str)
df_strings['General']=df_strings['General'].astype(str)
df_strings['Health']=df_strings['Health'].astype(str)
df_strings['Infrastructure']=df_strings['Infrastructure'].astype(str)
df_strings['Professional']=df_strings['Professional'].astype(str)
df_strings['Technology']=df_strings['Technology'].astype(str)
df_strings['Transport']=df_strings['Transport'].astype(str)

"""Create a column called "label" to enter the 0s or 1s of each class together in one column



"""

df_strings['label']=df_strings[['Defence','Education','Energy','General','Health','Infrastructure','Professional','Technology','Transport']].agg(''.join,axis=1)

df_strings = df_strings.drop(['Defence','Education','Energy','General','Health','Infrastructure','Professional','Technology','Transport'], axis=1)

real_test_docid=real_test_docid.to_frame()

"""Merge together in a DataFrame called "output" the "docid" column extracted before from the test dataset and the "label" column"""

output=pd.merge(real_test_docid, df_strings, left_index=True, right_index=True)

"""Export the final DataFrame called "output" which contains the columns "docid" and "label" with the same format as requested by kaggle"""

#output.to_csv('gru.csv', index = False)
#files.download("gru.csv")

"""## BERT Model"""

X_train = train_bert["features"].values.tolist()
X_valid = valid_bert["features"].values.tolist()

train_masks = train_bert["masks"].values.tolist()
valid_masks = valid_bert["masks"].values.tolist()

label_cols=['Defence','Education','Energy','General','Health','Infrastructure','Professional','Technology','Transport']
Y_train = train_bert[label_cols].values.tolist()
Y_valid = valid_bert[label_cols].values.tolist()

# create dataloaders
# Convert all of our input ids and attention masks into 
# torch tensors, the required datatype for our model

X_train = torch.tensor(X_train)
X_valid = torch.tensor(X_valid)

Y_train = torch.tensor(Y_train, dtype=torch.float32)
Y_valid = torch.tensor(Y_valid, dtype=torch.float32)

train_masks = torch.tensor(train_masks, dtype=torch.long)
valid_masks = torch.tensor(valid_masks, dtype=torch.long)

# Select a batch size for training
batch_size = 16

# Create an iterator of our data with torch DataLoader. This helps save on 
# memory during training because, unlike a for loop, 
# with an iterator the entire dataset does not need to be loaded into memory

train_data = TensorDataset(X_train, train_masks, Y_train)
train_sampler = RandomSampler(train_data)
train_dataloader = DataLoader(train_data,\
                              sampler=train_sampler,\
                              batch_size=batch_size)

validation_data = TensorDataset(X_valid, valid_masks, Y_valid)
validation_sampler = SequentialSampler(validation_data)
validation_dataloader = DataLoader(validation_data,\
                                   sampler=validation_sampler,\
                                   batch_size=batch_size)

# create function for training bert model
def train(model, num_epochs,\
          optimizer,\
          train_dataloader, valid_dataloader,\
          train_loss_set=[], valid_loss_set = [],\
          lowest_eval_loss=None, start_epoch=0,\
          device="cpu"
          ):
  """
  Train the model and save the model with the lowest validation loss
  """

  model.to(device)

  # trange is a tqdm wrapper around the normal python range
  for i in trange(num_epochs, desc="Epoch"):
    # if continue training from saved model
    actual_epoch = start_epoch + i

    # Training

    # Set our model to training mode (as opposed to evaluation mode)
    model.train()

    # Tracking variables
    tr_loss = 0
    num_train_samples = 0

    # Train the data for one epoch
    for step, batch in enumerate(train_dataloader):
      # Add batch to GPU
      batch = tuple(t.to(device) for t in batch)
      # Unpack the inputs from our dataloader
      b_input_ids, b_input_mask, b_labels = batch
      # Clear out the gradients (by default they accumulate)
      optimizer.zero_grad()
      # Forward pass
      loss = model(b_input_ids, attention_mask=b_input_mask, labels=b_labels)
      # store train loss
      tr_loss += loss.item()
      num_train_samples += b_labels.size(0)
      # Backward pass
      loss.backward()
      # Update parameters and take a step using the computed gradient
      optimizer.step()
      #scheduler.step()

    # Update tracking variables
    epoch_train_loss = tr_loss/num_train_samples
    train_loss_set.append(epoch_train_loss)

    print("Train loss: {}".format(epoch_train_loss))

    # Validation

    # Put model in evaluation mode to evaluate loss on the validation set
    model.eval()

    # Tracking variables 
    eval_loss = 0
    num_eval_samples = 0

    # Evaluate data for one epoch
    for batch in valid_dataloader:
      # Add batch to GPU
      batch = tuple(t.to(device) for t in batch)
      # Unpack the inputs from our dataloader
      b_input_ids, b_input_mask, b_labels = batch
      # Telling the model not to compute or store gradients,
      # saving memory and speeding up validation
      with torch.no_grad():
        # Forward pass, calculate validation loss
        loss = model(b_input_ids, attention_mask=b_input_mask, labels=b_labels)
        # store valid loss
        eval_loss += loss.item()
        num_eval_samples += b_labels.size(0)

    epoch_eval_loss = eval_loss/num_eval_samples
    valid_loss_set.append(epoch_eval_loss)

    print("Valid loss: {}".format(epoch_eval_loss))

    if lowest_eval_loss == None:
      lowest_eval_loss = epoch_eval_loss
      # save model
      #save_model(model, model_save_path, actual_epoch,\
       #          lowest_eval_loss, train_loss_set, valid_loss_set)
    else:
      if epoch_eval_loss < lowest_eval_loss:
        lowest_eval_loss = epoch_eval_loss
        # save model
        #save_model(model, model_save_path, actual_epoch,\
         #          lowest_eval_loss, train_loss_set, valid_loss_set)
    print("\n")

  return model, train_loss_set, valid_loss_set

# empty torch cache
torch.cuda.empty_cache()

# create class for bert model architecture
class BertforMultiLabelSequenceClassification(torch.nn.Module):
  
  def __init__(self, num_labels=2):
    super(BertforMultiLabelSequenceClassification, self).__init__()
    self.num_labels = num_labels
    self.bert = BertModel.from_pretrained('bert-base-multilingual-cased')
    self.dropout = torch.nn.Dropout(p=0.1)
    self.classifier = torch.nn.Linear(768, num_labels)

    torch.nn.init.xavier_normal_(self.classifier.weight)

  def forward(self, input_ids, token_type_ids=None,\
              attention_mask=None, labels=None):
    # last hidden layer
    last_hidden_state = self.bert(input_ids=input_ids,\
                                   attention_mask=attention_mask,\
                                   token_type_ids=token_type_ids)
    # pool the outputs into a mean vector
    mean_last_hidden_state = self.pool_hidden_state(last_hidden_state)
    mean_last_hidden_state = self.dropout(mean_last_hidden_state)
    logits = self.classifier(mean_last_hidden_state)
        
    if labels is not None:
      loss_fct = BCEWithLogitsLoss()
      loss = loss_fct(logits.view(-1, self.num_labels),\
                      labels.view(-1, self.num_labels))
      return loss
    else:
      return logits
    
  def freeze_bert_decoder(self):
    """
    Freeze BERT weight parameters. They will not be updated during training.
    """
    for param in self.bert.parameters():
      param.requires_grad = False
    
  def unfreeze_bert_decoder(self):
    """
    Unfreeze BERT weight parameters. They will be updated during training.
    """
    for param in self.bert.parameters():
      param.requires_grad = True
    
  def pool_hidden_state(self, last_hidden_state):
    """
    Pool the output vectors into a single mean vector 
    """
    last_hidden_state = last_hidden_state[0]
    mean_last_hidden_state = torch.mean(last_hidden_state, 1)
    return mean_last_hidden_state

class WarmupLinearSchedule(LambdaLR):
    """ Linear warmup and then linear decay.
        Linearly increases learning rate from 0 to 1 over `warmup_steps` training steps.
        Linearly decreases learning rate from 1. to 0. over remaining `t_total - warmup_steps` steps.
    """
    def __init__(self, optimizer, warmup_steps, t_total, last_epoch=-1):
        self.warmup_steps = warmup_steps
        self.t_total = t_total
        super(WarmupLinearSchedule, self).__init__(optimizer, self.lr_lambda, last_epoch=last_epoch)

    def lr_lambda(self, step):
        if step < self.warmup_steps:
            return float(step) / float(max(1, self.warmup_steps))
        return max(0.0, float(self.t_total - step) / float(max(1.0, self.t_total - self.warmup_steps)))

# assign model and optimizer
model = BertforMultiLabelSequenceClassification(num_labels=len(Y_train[0]))
optimizer = AdamW(model.parameters(), lr=2e-5, weight_decay=0.01, correct_bias=False)

# assign number of epochs and run Bert model
num_epochs=3
model, train_loss_set, valid_loss_set = train(model=model,\
                                              num_epochs=num_epochs,\
                                              optimizer=optimizer,\
                                              train_dataloader=train_dataloader,\
                                              valid_dataloader=validation_dataloader,\
                                              device="cuda")

# Plot loss
num_epochs = np.arange(len(train_loss_set))

fig, ax = plt.subplots(figsize=(10, 5));
ax.plot(num_epochs, np.array(train_loss_set), label="Train Loss")
ax.plot(num_epochs, np.array(valid_loss_set), 'g-', label="Valid Loss")
#ax1.plot(episode_record, lose_record, 'r-', label="Lose %")
ax.set_xlabel("Number of Epochs")
ax.set_ylabel("Loss")
ax.set_title("Loss vs Number of Epochs")

# create function for generating predictions for kaggle
def generate_predictions(model, df, num_labels, device="cpu", batch_size=32):
  num_iter = math.ceil(df.shape[0]/batch_size)
  
  pred_probs = np.array([]).reshape(0, num_labels)
  
  model.to(device)
  model.eval()
  
  for i in range(num_iter):
    df_subset = df.iloc[i*batch_size:(i+1)*batch_size,:]
    X = df_subset["features"].values.tolist()
    masks = df_subset["masks"].values.tolist()
    X = torch.tensor(X)
    masks = torch.tensor(masks, dtype=torch.long)
    X = X.to(device)
    masks = masks.to(device)
    with torch.no_grad():
      logits = model(input_ids=X, attention_mask=masks)
      logits = logits.sigmoid().detach().cpu().numpy()
      pred_probs = np.vstack([pred_probs, logits])
  
  return pred_probs

# generate predictictions 
pred_probs = generate_predictions(model, test, len(label_cols), device="cuda", batch_size=32)

label_cols=['Defence','Education','Energy','General','Health','Infrastructure','Professional','Technology','Transport']

test["Defence"] = pred_probs[:,0]
test["Education"] = pred_probs[:,1]
test["Energy"] = pred_probs[:,2]
test["General"] = pred_probs[:,3]
test["Health"] = pred_probs[:,4]
test["Infrastructure"] = pred_probs[:,5]
test["Professional"] = pred_probs[:,6]
test["Technology"] = pred_probs[:,7]
test["Transport"] = pred_probs[:,8]

test_to_csv = test.reset_index()

# pre-process data
test_to_csv = test_to_csv.drop(["text", "masks","features", "index"], axis=1)

# process df for submission
test_to_csv= test_to_csv.astype(int)
test_to_csv= test_to_csv.astype(str)
test_to_csv['label']=test_to_csv[label_cols].agg(''.join,axis=1)
test_to_csv = test_to_csv.drop([label_cols], axis=1)

test_to_csv.head()

#test_to_csv.to_csv("Bert_Predictions.csv", index=False)